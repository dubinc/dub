
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * WARNING: This is an internal file that is subject to change!
 *
 * ðŸ›‘ Under no circumstances should you import this file directly! ðŸ›‘
 *
 * All exports from this file are wrapped under a `Prisma` namespace object in the client.ts file.
 * While this enables partial backward compatibility, it is not part of the stable public API.
 *
 * If you are looking for your Models, Enums, and Input Types, please import them from the respective
 * model files in the `model` directory!
 */

import * as runtime from "@prisma/client/runtime/client"
import type * as Prisma from "../models"
import { type PrismaClient } from "./class"

export type * from '../models'

export type DMMF = typeof runtime.DMMF

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

/**
 * Prisma Errors
 */

export const PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
export type PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError

export const PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
export type PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError

export const PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
export type PrismaClientRustPanicError = runtime.PrismaClientRustPanicError

export const PrismaClientInitializationError = runtime.PrismaClientInitializationError
export type PrismaClientInitializationError = runtime.PrismaClientInitializationError

export const PrismaClientValidationError = runtime.PrismaClientValidationError
export type PrismaClientValidationError = runtime.PrismaClientValidationError

/**
 * Re-export of sql-template-tag
 */
export const sql = runtime.sqltag
export const empty = runtime.empty
export const join = runtime.join
export const raw = runtime.raw
export const Sql = runtime.Sql
export type Sql = runtime.Sql



/**
 * Decimal.js
 */
export const Decimal = runtime.Decimal
export type Decimal = runtime.Decimal

export type DecimalJsLike = runtime.DecimalJsLike

/**
 * Metrics
 */
export type Metrics = runtime.Metrics
export type Metric<T> = runtime.Metric<T>
export type MetricHistogram = runtime.MetricHistogram
export type MetricHistogramBucket = runtime.MetricHistogramBucket

/**
* Extensions
*/
export type Extension = runtime.Types.Extensions.UserArgs
export const getExtensionContext = runtime.Extensions.getExtensionContext
export type Args<T, F extends runtime.Operation> = runtime.Types.Public.Args<T, F>
export type Payload<T, F extends runtime.Operation = never> = runtime.Types.Public.Payload<T, F>
export type Result<T, A, F extends runtime.Operation> = runtime.Types.Public.Result<T, A, F>
export type Exact<A, W> = runtime.Types.Public.Exact<A, W>

export type PrismaVersion = {
  client: string
  engine: string
}

/**
 * Prisma Client JS version: 6.19.1
 * Query Engine version: c2990dca591cba766e3b7ef5d9e8a84796e47ab7
 */
export const prismaVersion: PrismaVersion = {
  client: "6.19.1",
  engine: "c2990dca591cba766e3b7ef5d9e8a84796e47ab7"
}

/**
 * Utility Types
 */

export type Bytes = runtime.Bytes
export type JsonObject = runtime.JsonObject
export type JsonArray = runtime.JsonArray
export type JsonValue = runtime.JsonValue
export type InputJsonObject = runtime.InputJsonObject
export type InputJsonArray = runtime.InputJsonArray
export type InputJsonValue = runtime.InputJsonValue


export const NullTypes = {
  DbNull: runtime.objectEnumValues.classes.DbNull as (new (secret: never) => typeof runtime.objectEnumValues.instances.DbNull),
  JsonNull: runtime.objectEnumValues.classes.JsonNull as (new (secret: never) => typeof runtime.objectEnumValues.instances.JsonNull),
  AnyNull: runtime.objectEnumValues.classes.AnyNull as (new (secret: never) => typeof runtime.objectEnumValues.instances.AnyNull),
}
/**
 * Helper for filtering JSON entries that have `null` on the database (empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const DbNull = runtime.objectEnumValues.instances.DbNull
/**
 * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const JsonNull = runtime.objectEnumValues.instances.JsonNull
/**
 * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const AnyNull = runtime.objectEnumValues.instances.AnyNull


type SelectAndInclude = {
  select: any
  include: any
}

type SelectAndOmit = {
  select: any
  omit: any
}

/**
 * From T, pick a set of properties whose keys are in the union K
 */
type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
};

export type Enumerable<T> = T | Array<T>;

/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */
export type Subset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
};

/**
 * SelectSubset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
 * Additionally, it validates, if both select and include are present. If the case, it errors.
 */
export type SelectSubset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  (T extends SelectAndInclude
    ? 'Please either choose `select` or `include`.'
    : T extends SelectAndOmit
      ? 'Please either choose `select` or `omit`.'
      : {})

/**
 * Subset + Intersection
 * @desc From `T` pick properties that exist in `U` and intersect `K`
 */
export type SubsetIntersection<T, U, K> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  K

type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

/**
 * XOR is needed to have a real mutually exclusive union type
 * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
 */
export type XOR<T, U> =
  T extends object ?
  U extends object ?
    (Without<T, U> & U) | (Without<U, T> & T)
  : U : T


/**
 * Is T a Record?
 */
type IsObject<T extends any> = T extends Array<any>
? False
: T extends Date
? False
: T extends Uint8Array
? False
: T extends BigInt
? False
: T extends object
? True
: False


/**
 * If it's T[], return T
 */
export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

/**
 * From ts-toolbelt
 */

type __Either<O extends object, K extends Key> = Omit<O, K> &
  {
    // Merge all but K
    [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
  }[K]

type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

type _Either<
  O extends object,
  K extends Key,
  strict extends Boolean
> = {
  1: EitherStrict<O, K>
  0: EitherLoose<O, K>
}[strict]

export type Either<
  O extends object,
  K extends Key,
  strict extends Boolean = 1
> = O extends unknown ? _Either<O, K, strict> : never

export type Union = any

export type PatchUndefined<O extends object, O1 extends object> = {
  [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
} & {}

/** Helper Types for "Merge" **/
export type IntersectOf<U extends Union> = (
  U extends unknown ? (k: U) => void : never
) extends (k: infer I) => void
  ? I
  : never

export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
} & {};

type _Merge<U extends object> = IntersectOf<Overwrite<U, {
    [K in keyof U]-?: At<U, K>;
}>>;

type Key = string | number | symbol;
type AtStrict<O extends object, K extends Key> = O[K & keyof O];
type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
}[strict];

export type ComputeRaw<A extends any> = A extends Function ? A : {
  [K in keyof A]: A[K];
} & {};

export type OptionalFlat<O> = {
  [K in keyof O]?: O[K];
} & {};

type _Record<K extends keyof any, T> = {
  [P in K]: T;
};

// cause typescript not to expand types and preserve names
type NoExpand<T> = T extends unknown ? T : never;

// this type assumes the passed object is entirely optional
export type AtLeast<O extends object, K extends string> = NoExpand<
  O extends unknown
  ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
    | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
  : never>;

type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
/** End Helper Types for "Merge" **/

export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

export type Boolean = True | False

export type True = 1

export type False = 0

export type Not<B extends Boolean> = {
  0: 1
  1: 0
}[B]

export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
  ? 0 // anything `never` is false
  : A1 extends A2
  ? 1
  : 0

export type Has<U extends Union, U1 extends Union> = Not<
  Extends<Exclude<U1, U>, U1>
>

export type Or<B1 extends Boolean, B2 extends Boolean> = {
  0: {
    0: 0
    1: 1
  }
  1: {
    0: 1
    1: 1
  }
}[B1][B2]

export type Keys<U extends Union> = U extends unknown ? keyof U : never

export type GetScalarType<T, O> = O extends object ? {
  [P in keyof T]: P extends keyof O
    ? O[P]
    : never
} : never

type FieldPaths<
  T,
  U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
> = IsObject<T> extends True ? U : T

export type GetHavingFields<T> = {
  [K in keyof T]: Or<
    Or<Extends<'OR', K>, Extends<'AND', K>>,
    Extends<'NOT', K>
  > extends True
    ? // infer is only needed to not hit TS limit
      // based on the brilliant idea of Pierre-Antoine Mills
      // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
      T[K] extends infer TK
      ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
      : never
    : {} extends FieldPaths<T[K]>
    ? never
    : K
}[keyof T]

/**
 * Convert tuple to union
 */
type _TupleToUnion<T> = T extends (infer E)[] ? E : never
type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
export type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

/**
 * Like `Pick`, but additionally can also accept an array of keys
 */
export type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

/**
 * Exclude all keys with underscores
 */
export type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


export const ModelName = {
  Bounty: 'Bounty',
  BountyGroup: 'BountyGroup',
  BountySubmission: 'BountySubmission',
  Campaign: 'Campaign',
  CampaignGroup: 'CampaignGroup',
  PartnerComment: 'PartnerComment',
  Commission: 'Commission',
  Customer: 'Customer',
  Dashboard: 'Dashboard',
  Discount: 'Discount',
  DiscountCode: 'DiscountCode',
  Domain: 'Domain',
  RegisteredDomain: 'RegisteredDomain',
  DefaultDomains: 'DefaultDomains',
  EmailDomain: 'EmailDomain',
  Folder: 'Folder',
  FolderUser: 'FolderUser',
  FolderAccessRequest: 'FolderAccessRequest',
  FraudRule: 'FraudRule',
  FraudEventGroup: 'FraudEventGroup',
  FraudEvent: 'FraudEvent',
  PartnerGroup: 'PartnerGroup',
  PartnerGroupDefaultLink: 'PartnerGroupDefaultLink',
  Integration: 'Integration',
  InstalledIntegration: 'InstalledIntegration',
  Invoice: 'Invoice',
  jackson_index: 'jackson_index',
  jackson_store: 'jackson_store',
  jackson_ttl: 'jackson_ttl',
  Link: 'Link',
  Message: 'Message',
  YearInReview: 'YearInReview',
  PartnerRewind: 'PartnerRewind',
  ProgramCategory: 'ProgramCategory',
  ProgramSimilarity: 'ProgramSimilarity',
  DiscoveredPartner: 'DiscoveredPartner',
  NotificationEmail: 'NotificationEmail',
  NotificationPreference: 'NotificationPreference',
  PartnerNotificationPreferences: 'PartnerNotificationPreferences',
  OAuthApp: 'OAuthApp',
  OAuthCode: 'OAuthCode',
  OAuthRefreshToken: 'OAuthRefreshToken',
  Partner: 'Partner',
  PartnerInvite: 'PartnerInvite',
  PartnerUser: 'PartnerUser',
  PartnerIndustryInterest: 'PartnerIndustryInterest',
  PartnerPreferredEarningStructure: 'PartnerPreferredEarningStructure',
  PartnerSalesChannel: 'PartnerSalesChannel',
  Payout: 'Payout',
  Program: 'Program',
  ProgramEnrollment: 'ProgramEnrollment',
  ProgramApplication: 'ProgramApplication',
  Reward: 'Reward',
  User: 'User',
  Account: 'Account',
  Session: 'Session',
  Tag: 'Tag',
  LinkTag: 'LinkTag',
  Token: 'Token',
  RestrictedToken: 'RestrictedToken',
  VerificationToken: 'VerificationToken',
  EmailVerificationToken: 'EmailVerificationToken',
  PasswordResetToken: 'PasswordResetToken',
  UtmTemplate: 'UtmTemplate',
  Webhook: 'Webhook',
  LinkWebhook: 'LinkWebhook',
  Workflow: 'Workflow',
  Project: 'Project',
  ProjectInvite: 'ProjectInvite',
  ProjectUsers: 'ProjectUsers',
  SentEmail: 'SentEmail'
} as const

export type ModelName = (typeof ModelName)[keyof typeof ModelName]



export interface TypeMapCb<GlobalOmitOptions = {}> extends runtime.Types.Utils.Fn<{extArgs: runtime.Types.Extensions.InternalArgs }, runtime.Types.Utils.Record<string, any>> {
  returns: TypeMap<this['params']['extArgs'], GlobalOmitOptions>
}

export type TypeMap<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
  globalOmitOptions: {
    omit: GlobalOmitOptions
  }
  meta: {
    modelProps: "bounty" | "bountyGroup" | "bountySubmission" | "campaign" | "campaignGroup" | "partnerComment" | "commission" | "customer" | "dashboard" | "discount" | "discountCode" | "domain" | "registeredDomain" | "defaultDomains" | "emailDomain" | "folder" | "folderUser" | "folderAccessRequest" | "fraudRule" | "fraudEventGroup" | "fraudEvent" | "partnerGroup" | "partnerGroupDefaultLink" | "integration" | "installedIntegration" | "invoice" | "jackson_index" | "jackson_store" | "jackson_ttl" | "link" | "message" | "yearInReview" | "partnerRewind" | "programCategory" | "programSimilarity" | "discoveredPartner" | "notificationEmail" | "notificationPreference" | "partnerNotificationPreferences" | "oAuthApp" | "oAuthCode" | "oAuthRefreshToken" | "partner" | "partnerInvite" | "partnerUser" | "partnerIndustryInterest" | "partnerPreferredEarningStructure" | "partnerSalesChannel" | "payout" | "program" | "programEnrollment" | "programApplication" | "reward" | "user" | "account" | "session" | "tag" | "linkTag" | "token" | "restrictedToken" | "verificationToken" | "emailVerificationToken" | "passwordResetToken" | "utmTemplate" | "webhook" | "linkWebhook" | "workflow" | "project" | "projectInvite" | "projectUsers" | "sentEmail"
    txIsolationLevel: TransactionIsolationLevel
  }
  model: {
    Bounty: {
      payload: Prisma.$BountyPayload<ExtArgs>
      fields: Prisma.BountyFieldRefs
      operations: {
        findUnique: {
          args: Prisma.BountyFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BountyPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.BountyFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BountyPayload>
        }
        findFirst: {
          args: Prisma.BountyFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BountyPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.BountyFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BountyPayload>
        }
        findMany: {
          args: Prisma.BountyFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BountyPayload>[]
        }
        create: {
          args: Prisma.BountyCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BountyPayload>
        }
        createMany: {
          args: Prisma.BountyCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.BountyDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BountyPayload>
        }
        update: {
          args: Prisma.BountyUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BountyPayload>
        }
        deleteMany: {
          args: Prisma.BountyDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.BountyUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.BountyUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BountyPayload>
        }
        aggregate: {
          args: Prisma.BountyAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateBounty>
        }
        groupBy: {
          args: Prisma.BountyGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BountyGroupByOutputType>[]
        }
        count: {
          args: Prisma.BountyCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BountyCountAggregateOutputType> | number
        }
      }
    }
    BountyGroup: {
      payload: Prisma.$BountyGroupPayload<ExtArgs>
      fields: Prisma.BountyGroupFieldRefs
      operations: {
        findUnique: {
          args: Prisma.BountyGroupFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BountyGroupPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.BountyGroupFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BountyGroupPayload>
        }
        findFirst: {
          args: Prisma.BountyGroupFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BountyGroupPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.BountyGroupFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BountyGroupPayload>
        }
        findMany: {
          args: Prisma.BountyGroupFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BountyGroupPayload>[]
        }
        create: {
          args: Prisma.BountyGroupCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BountyGroupPayload>
        }
        createMany: {
          args: Prisma.BountyGroupCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.BountyGroupDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BountyGroupPayload>
        }
        update: {
          args: Prisma.BountyGroupUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BountyGroupPayload>
        }
        deleteMany: {
          args: Prisma.BountyGroupDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.BountyGroupUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.BountyGroupUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BountyGroupPayload>
        }
        aggregate: {
          args: Prisma.BountyGroupAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateBountyGroup>
        }
        groupBy: {
          args: Prisma.BountyGroupGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BountyGroupGroupByOutputType>[]
        }
        count: {
          args: Prisma.BountyGroupCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BountyGroupCountAggregateOutputType> | number
        }
      }
    }
    BountySubmission: {
      payload: Prisma.$BountySubmissionPayload<ExtArgs>
      fields: Prisma.BountySubmissionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.BountySubmissionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BountySubmissionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.BountySubmissionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BountySubmissionPayload>
        }
        findFirst: {
          args: Prisma.BountySubmissionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BountySubmissionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.BountySubmissionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BountySubmissionPayload>
        }
        findMany: {
          args: Prisma.BountySubmissionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BountySubmissionPayload>[]
        }
        create: {
          args: Prisma.BountySubmissionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BountySubmissionPayload>
        }
        createMany: {
          args: Prisma.BountySubmissionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.BountySubmissionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BountySubmissionPayload>
        }
        update: {
          args: Prisma.BountySubmissionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BountySubmissionPayload>
        }
        deleteMany: {
          args: Prisma.BountySubmissionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.BountySubmissionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.BountySubmissionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BountySubmissionPayload>
        }
        aggregate: {
          args: Prisma.BountySubmissionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateBountySubmission>
        }
        groupBy: {
          args: Prisma.BountySubmissionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BountySubmissionGroupByOutputType>[]
        }
        count: {
          args: Prisma.BountySubmissionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BountySubmissionCountAggregateOutputType> | number
        }
      }
    }
    Campaign: {
      payload: Prisma.$CampaignPayload<ExtArgs>
      fields: Prisma.CampaignFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CampaignFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampaignPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CampaignFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampaignPayload>
        }
        findFirst: {
          args: Prisma.CampaignFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampaignPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CampaignFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampaignPayload>
        }
        findMany: {
          args: Prisma.CampaignFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampaignPayload>[]
        }
        create: {
          args: Prisma.CampaignCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampaignPayload>
        }
        createMany: {
          args: Prisma.CampaignCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.CampaignDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampaignPayload>
        }
        update: {
          args: Prisma.CampaignUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampaignPayload>
        }
        deleteMany: {
          args: Prisma.CampaignDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CampaignUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.CampaignUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampaignPayload>
        }
        aggregate: {
          args: Prisma.CampaignAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCampaign>
        }
        groupBy: {
          args: Prisma.CampaignGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CampaignGroupByOutputType>[]
        }
        count: {
          args: Prisma.CampaignCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CampaignCountAggregateOutputType> | number
        }
      }
    }
    CampaignGroup: {
      payload: Prisma.$CampaignGroupPayload<ExtArgs>
      fields: Prisma.CampaignGroupFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CampaignGroupFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampaignGroupPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CampaignGroupFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampaignGroupPayload>
        }
        findFirst: {
          args: Prisma.CampaignGroupFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampaignGroupPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CampaignGroupFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampaignGroupPayload>
        }
        findMany: {
          args: Prisma.CampaignGroupFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampaignGroupPayload>[]
        }
        create: {
          args: Prisma.CampaignGroupCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampaignGroupPayload>
        }
        createMany: {
          args: Prisma.CampaignGroupCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.CampaignGroupDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampaignGroupPayload>
        }
        update: {
          args: Prisma.CampaignGroupUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampaignGroupPayload>
        }
        deleteMany: {
          args: Prisma.CampaignGroupDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CampaignGroupUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.CampaignGroupUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampaignGroupPayload>
        }
        aggregate: {
          args: Prisma.CampaignGroupAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCampaignGroup>
        }
        groupBy: {
          args: Prisma.CampaignGroupGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CampaignGroupGroupByOutputType>[]
        }
        count: {
          args: Prisma.CampaignGroupCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CampaignGroupCountAggregateOutputType> | number
        }
      }
    }
    PartnerComment: {
      payload: Prisma.$PartnerCommentPayload<ExtArgs>
      fields: Prisma.PartnerCommentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PartnerCommentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerCommentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PartnerCommentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerCommentPayload>
        }
        findFirst: {
          args: Prisma.PartnerCommentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerCommentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PartnerCommentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerCommentPayload>
        }
        findMany: {
          args: Prisma.PartnerCommentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerCommentPayload>[]
        }
        create: {
          args: Prisma.PartnerCommentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerCommentPayload>
        }
        createMany: {
          args: Prisma.PartnerCommentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.PartnerCommentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerCommentPayload>
        }
        update: {
          args: Prisma.PartnerCommentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerCommentPayload>
        }
        deleteMany: {
          args: Prisma.PartnerCommentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PartnerCommentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.PartnerCommentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerCommentPayload>
        }
        aggregate: {
          args: Prisma.PartnerCommentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePartnerComment>
        }
        groupBy: {
          args: Prisma.PartnerCommentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PartnerCommentGroupByOutputType>[]
        }
        count: {
          args: Prisma.PartnerCommentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PartnerCommentCountAggregateOutputType> | number
        }
      }
    }
    Commission: {
      payload: Prisma.$CommissionPayload<ExtArgs>
      fields: Prisma.CommissionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CommissionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommissionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CommissionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommissionPayload>
        }
        findFirst: {
          args: Prisma.CommissionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommissionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CommissionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommissionPayload>
        }
        findMany: {
          args: Prisma.CommissionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommissionPayload>[]
        }
        create: {
          args: Prisma.CommissionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommissionPayload>
        }
        createMany: {
          args: Prisma.CommissionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.CommissionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommissionPayload>
        }
        update: {
          args: Prisma.CommissionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommissionPayload>
        }
        deleteMany: {
          args: Prisma.CommissionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CommissionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.CommissionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommissionPayload>
        }
        aggregate: {
          args: Prisma.CommissionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCommission>
        }
        groupBy: {
          args: Prisma.CommissionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CommissionGroupByOutputType>[]
        }
        count: {
          args: Prisma.CommissionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CommissionCountAggregateOutputType> | number
        }
      }
    }
    Customer: {
      payload: Prisma.$CustomerPayload<ExtArgs>
      fields: Prisma.CustomerFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CustomerFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload>
        }
        findFirst: {
          args: Prisma.CustomerFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload>
        }
        findMany: {
          args: Prisma.CustomerFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload>[]
        }
        create: {
          args: Prisma.CustomerCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload>
        }
        createMany: {
          args: Prisma.CustomerCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.CustomerDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload>
        }
        update: {
          args: Prisma.CustomerUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload>
        }
        deleteMany: {
          args: Prisma.CustomerDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CustomerUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.CustomerUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload>
        }
        aggregate: {
          args: Prisma.CustomerAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCustomer>
        }
        groupBy: {
          args: Prisma.CustomerGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CustomerGroupByOutputType>[]
        }
        count: {
          args: Prisma.CustomerCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CustomerCountAggregateOutputType> | number
        }
      }
    }
    Dashboard: {
      payload: Prisma.$DashboardPayload<ExtArgs>
      fields: Prisma.DashboardFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DashboardFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DashboardPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DashboardFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DashboardPayload>
        }
        findFirst: {
          args: Prisma.DashboardFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DashboardPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DashboardFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DashboardPayload>
        }
        findMany: {
          args: Prisma.DashboardFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DashboardPayload>[]
        }
        create: {
          args: Prisma.DashboardCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DashboardPayload>
        }
        createMany: {
          args: Prisma.DashboardCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.DashboardDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DashboardPayload>
        }
        update: {
          args: Prisma.DashboardUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DashboardPayload>
        }
        deleteMany: {
          args: Prisma.DashboardDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DashboardUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.DashboardUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DashboardPayload>
        }
        aggregate: {
          args: Prisma.DashboardAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDashboard>
        }
        groupBy: {
          args: Prisma.DashboardGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DashboardGroupByOutputType>[]
        }
        count: {
          args: Prisma.DashboardCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DashboardCountAggregateOutputType> | number
        }
      }
    }
    Discount: {
      payload: Prisma.$DiscountPayload<ExtArgs>
      fields: Prisma.DiscountFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DiscountFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscountPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DiscountFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscountPayload>
        }
        findFirst: {
          args: Prisma.DiscountFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscountPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DiscountFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscountPayload>
        }
        findMany: {
          args: Prisma.DiscountFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscountPayload>[]
        }
        create: {
          args: Prisma.DiscountCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscountPayload>
        }
        createMany: {
          args: Prisma.DiscountCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.DiscountDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscountPayload>
        }
        update: {
          args: Prisma.DiscountUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscountPayload>
        }
        deleteMany: {
          args: Prisma.DiscountDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DiscountUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.DiscountUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscountPayload>
        }
        aggregate: {
          args: Prisma.DiscountAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDiscount>
        }
        groupBy: {
          args: Prisma.DiscountGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DiscountGroupByOutputType>[]
        }
        count: {
          args: Prisma.DiscountCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DiscountCountAggregateOutputType> | number
        }
      }
    }
    DiscountCode: {
      payload: Prisma.$DiscountCodePayload<ExtArgs>
      fields: Prisma.DiscountCodeFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DiscountCodeFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscountCodePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DiscountCodeFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscountCodePayload>
        }
        findFirst: {
          args: Prisma.DiscountCodeFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscountCodePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DiscountCodeFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscountCodePayload>
        }
        findMany: {
          args: Prisma.DiscountCodeFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscountCodePayload>[]
        }
        create: {
          args: Prisma.DiscountCodeCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscountCodePayload>
        }
        createMany: {
          args: Prisma.DiscountCodeCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.DiscountCodeDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscountCodePayload>
        }
        update: {
          args: Prisma.DiscountCodeUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscountCodePayload>
        }
        deleteMany: {
          args: Prisma.DiscountCodeDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DiscountCodeUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.DiscountCodeUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscountCodePayload>
        }
        aggregate: {
          args: Prisma.DiscountCodeAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDiscountCode>
        }
        groupBy: {
          args: Prisma.DiscountCodeGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DiscountCodeGroupByOutputType>[]
        }
        count: {
          args: Prisma.DiscountCodeCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DiscountCodeCountAggregateOutputType> | number
        }
      }
    }
    Domain: {
      payload: Prisma.$DomainPayload<ExtArgs>
      fields: Prisma.DomainFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DomainFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DomainPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DomainFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DomainPayload>
        }
        findFirst: {
          args: Prisma.DomainFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DomainPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DomainFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DomainPayload>
        }
        findMany: {
          args: Prisma.DomainFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DomainPayload>[]
        }
        create: {
          args: Prisma.DomainCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DomainPayload>
        }
        createMany: {
          args: Prisma.DomainCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.DomainDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DomainPayload>
        }
        update: {
          args: Prisma.DomainUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DomainPayload>
        }
        deleteMany: {
          args: Prisma.DomainDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DomainUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.DomainUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DomainPayload>
        }
        aggregate: {
          args: Prisma.DomainAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDomain>
        }
        groupBy: {
          args: Prisma.DomainGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DomainGroupByOutputType>[]
        }
        count: {
          args: Prisma.DomainCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DomainCountAggregateOutputType> | number
        }
      }
    }
    RegisteredDomain: {
      payload: Prisma.$RegisteredDomainPayload<ExtArgs>
      fields: Prisma.RegisteredDomainFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RegisteredDomainFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RegisteredDomainPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RegisteredDomainFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RegisteredDomainPayload>
        }
        findFirst: {
          args: Prisma.RegisteredDomainFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RegisteredDomainPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RegisteredDomainFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RegisteredDomainPayload>
        }
        findMany: {
          args: Prisma.RegisteredDomainFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RegisteredDomainPayload>[]
        }
        create: {
          args: Prisma.RegisteredDomainCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RegisteredDomainPayload>
        }
        createMany: {
          args: Prisma.RegisteredDomainCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.RegisteredDomainDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RegisteredDomainPayload>
        }
        update: {
          args: Prisma.RegisteredDomainUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RegisteredDomainPayload>
        }
        deleteMany: {
          args: Prisma.RegisteredDomainDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RegisteredDomainUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.RegisteredDomainUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RegisteredDomainPayload>
        }
        aggregate: {
          args: Prisma.RegisteredDomainAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRegisteredDomain>
        }
        groupBy: {
          args: Prisma.RegisteredDomainGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RegisteredDomainGroupByOutputType>[]
        }
        count: {
          args: Prisma.RegisteredDomainCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RegisteredDomainCountAggregateOutputType> | number
        }
      }
    }
    DefaultDomains: {
      payload: Prisma.$DefaultDomainsPayload<ExtArgs>
      fields: Prisma.DefaultDomainsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DefaultDomainsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DefaultDomainsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DefaultDomainsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DefaultDomainsPayload>
        }
        findFirst: {
          args: Prisma.DefaultDomainsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DefaultDomainsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DefaultDomainsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DefaultDomainsPayload>
        }
        findMany: {
          args: Prisma.DefaultDomainsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DefaultDomainsPayload>[]
        }
        create: {
          args: Prisma.DefaultDomainsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DefaultDomainsPayload>
        }
        createMany: {
          args: Prisma.DefaultDomainsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.DefaultDomainsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DefaultDomainsPayload>
        }
        update: {
          args: Prisma.DefaultDomainsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DefaultDomainsPayload>
        }
        deleteMany: {
          args: Prisma.DefaultDomainsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DefaultDomainsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.DefaultDomainsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DefaultDomainsPayload>
        }
        aggregate: {
          args: Prisma.DefaultDomainsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDefaultDomains>
        }
        groupBy: {
          args: Prisma.DefaultDomainsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DefaultDomainsGroupByOutputType>[]
        }
        count: {
          args: Prisma.DefaultDomainsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DefaultDomainsCountAggregateOutputType> | number
        }
      }
    }
    EmailDomain: {
      payload: Prisma.$EmailDomainPayload<ExtArgs>
      fields: Prisma.EmailDomainFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EmailDomainFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailDomainPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EmailDomainFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailDomainPayload>
        }
        findFirst: {
          args: Prisma.EmailDomainFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailDomainPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EmailDomainFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailDomainPayload>
        }
        findMany: {
          args: Prisma.EmailDomainFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailDomainPayload>[]
        }
        create: {
          args: Prisma.EmailDomainCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailDomainPayload>
        }
        createMany: {
          args: Prisma.EmailDomainCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.EmailDomainDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailDomainPayload>
        }
        update: {
          args: Prisma.EmailDomainUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailDomainPayload>
        }
        deleteMany: {
          args: Prisma.EmailDomainDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EmailDomainUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.EmailDomainUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailDomainPayload>
        }
        aggregate: {
          args: Prisma.EmailDomainAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEmailDomain>
        }
        groupBy: {
          args: Prisma.EmailDomainGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EmailDomainGroupByOutputType>[]
        }
        count: {
          args: Prisma.EmailDomainCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EmailDomainCountAggregateOutputType> | number
        }
      }
    }
    Folder: {
      payload: Prisma.$FolderPayload<ExtArgs>
      fields: Prisma.FolderFieldRefs
      operations: {
        findUnique: {
          args: Prisma.FolderFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FolderPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.FolderFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FolderPayload>
        }
        findFirst: {
          args: Prisma.FolderFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FolderPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.FolderFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FolderPayload>
        }
        findMany: {
          args: Prisma.FolderFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FolderPayload>[]
        }
        create: {
          args: Prisma.FolderCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FolderPayload>
        }
        createMany: {
          args: Prisma.FolderCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.FolderDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FolderPayload>
        }
        update: {
          args: Prisma.FolderUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FolderPayload>
        }
        deleteMany: {
          args: Prisma.FolderDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.FolderUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.FolderUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FolderPayload>
        }
        aggregate: {
          args: Prisma.FolderAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateFolder>
        }
        groupBy: {
          args: Prisma.FolderGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FolderGroupByOutputType>[]
        }
        count: {
          args: Prisma.FolderCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FolderCountAggregateOutputType> | number
        }
      }
    }
    FolderUser: {
      payload: Prisma.$FolderUserPayload<ExtArgs>
      fields: Prisma.FolderUserFieldRefs
      operations: {
        findUnique: {
          args: Prisma.FolderUserFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FolderUserPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.FolderUserFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FolderUserPayload>
        }
        findFirst: {
          args: Prisma.FolderUserFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FolderUserPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.FolderUserFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FolderUserPayload>
        }
        findMany: {
          args: Prisma.FolderUserFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FolderUserPayload>[]
        }
        create: {
          args: Prisma.FolderUserCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FolderUserPayload>
        }
        createMany: {
          args: Prisma.FolderUserCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.FolderUserDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FolderUserPayload>
        }
        update: {
          args: Prisma.FolderUserUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FolderUserPayload>
        }
        deleteMany: {
          args: Prisma.FolderUserDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.FolderUserUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.FolderUserUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FolderUserPayload>
        }
        aggregate: {
          args: Prisma.FolderUserAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateFolderUser>
        }
        groupBy: {
          args: Prisma.FolderUserGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FolderUserGroupByOutputType>[]
        }
        count: {
          args: Prisma.FolderUserCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FolderUserCountAggregateOutputType> | number
        }
      }
    }
    FolderAccessRequest: {
      payload: Prisma.$FolderAccessRequestPayload<ExtArgs>
      fields: Prisma.FolderAccessRequestFieldRefs
      operations: {
        findUnique: {
          args: Prisma.FolderAccessRequestFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FolderAccessRequestPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.FolderAccessRequestFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FolderAccessRequestPayload>
        }
        findFirst: {
          args: Prisma.FolderAccessRequestFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FolderAccessRequestPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.FolderAccessRequestFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FolderAccessRequestPayload>
        }
        findMany: {
          args: Prisma.FolderAccessRequestFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FolderAccessRequestPayload>[]
        }
        create: {
          args: Prisma.FolderAccessRequestCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FolderAccessRequestPayload>
        }
        createMany: {
          args: Prisma.FolderAccessRequestCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.FolderAccessRequestDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FolderAccessRequestPayload>
        }
        update: {
          args: Prisma.FolderAccessRequestUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FolderAccessRequestPayload>
        }
        deleteMany: {
          args: Prisma.FolderAccessRequestDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.FolderAccessRequestUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.FolderAccessRequestUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FolderAccessRequestPayload>
        }
        aggregate: {
          args: Prisma.FolderAccessRequestAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateFolderAccessRequest>
        }
        groupBy: {
          args: Prisma.FolderAccessRequestGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FolderAccessRequestGroupByOutputType>[]
        }
        count: {
          args: Prisma.FolderAccessRequestCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FolderAccessRequestCountAggregateOutputType> | number
        }
      }
    }
    FraudRule: {
      payload: Prisma.$FraudRulePayload<ExtArgs>
      fields: Prisma.FraudRuleFieldRefs
      operations: {
        findUnique: {
          args: Prisma.FraudRuleFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FraudRulePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.FraudRuleFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FraudRulePayload>
        }
        findFirst: {
          args: Prisma.FraudRuleFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FraudRulePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.FraudRuleFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FraudRulePayload>
        }
        findMany: {
          args: Prisma.FraudRuleFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FraudRulePayload>[]
        }
        create: {
          args: Prisma.FraudRuleCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FraudRulePayload>
        }
        createMany: {
          args: Prisma.FraudRuleCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.FraudRuleDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FraudRulePayload>
        }
        update: {
          args: Prisma.FraudRuleUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FraudRulePayload>
        }
        deleteMany: {
          args: Prisma.FraudRuleDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.FraudRuleUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.FraudRuleUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FraudRulePayload>
        }
        aggregate: {
          args: Prisma.FraudRuleAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateFraudRule>
        }
        groupBy: {
          args: Prisma.FraudRuleGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FraudRuleGroupByOutputType>[]
        }
        count: {
          args: Prisma.FraudRuleCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FraudRuleCountAggregateOutputType> | number
        }
      }
    }
    FraudEventGroup: {
      payload: Prisma.$FraudEventGroupPayload<ExtArgs>
      fields: Prisma.FraudEventGroupFieldRefs
      operations: {
        findUnique: {
          args: Prisma.FraudEventGroupFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FraudEventGroupPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.FraudEventGroupFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FraudEventGroupPayload>
        }
        findFirst: {
          args: Prisma.FraudEventGroupFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FraudEventGroupPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.FraudEventGroupFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FraudEventGroupPayload>
        }
        findMany: {
          args: Prisma.FraudEventGroupFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FraudEventGroupPayload>[]
        }
        create: {
          args: Prisma.FraudEventGroupCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FraudEventGroupPayload>
        }
        createMany: {
          args: Prisma.FraudEventGroupCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.FraudEventGroupDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FraudEventGroupPayload>
        }
        update: {
          args: Prisma.FraudEventGroupUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FraudEventGroupPayload>
        }
        deleteMany: {
          args: Prisma.FraudEventGroupDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.FraudEventGroupUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.FraudEventGroupUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FraudEventGroupPayload>
        }
        aggregate: {
          args: Prisma.FraudEventGroupAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateFraudEventGroup>
        }
        groupBy: {
          args: Prisma.FraudEventGroupGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FraudEventGroupGroupByOutputType>[]
        }
        count: {
          args: Prisma.FraudEventGroupCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FraudEventGroupCountAggregateOutputType> | number
        }
      }
    }
    FraudEvent: {
      payload: Prisma.$FraudEventPayload<ExtArgs>
      fields: Prisma.FraudEventFieldRefs
      operations: {
        findUnique: {
          args: Prisma.FraudEventFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FraudEventPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.FraudEventFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FraudEventPayload>
        }
        findFirst: {
          args: Prisma.FraudEventFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FraudEventPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.FraudEventFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FraudEventPayload>
        }
        findMany: {
          args: Prisma.FraudEventFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FraudEventPayload>[]
        }
        create: {
          args: Prisma.FraudEventCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FraudEventPayload>
        }
        createMany: {
          args: Prisma.FraudEventCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.FraudEventDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FraudEventPayload>
        }
        update: {
          args: Prisma.FraudEventUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FraudEventPayload>
        }
        deleteMany: {
          args: Prisma.FraudEventDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.FraudEventUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.FraudEventUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FraudEventPayload>
        }
        aggregate: {
          args: Prisma.FraudEventAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateFraudEvent>
        }
        groupBy: {
          args: Prisma.FraudEventGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FraudEventGroupByOutputType>[]
        }
        count: {
          args: Prisma.FraudEventCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FraudEventCountAggregateOutputType> | number
        }
      }
    }
    PartnerGroup: {
      payload: Prisma.$PartnerGroupPayload<ExtArgs>
      fields: Prisma.PartnerGroupFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PartnerGroupFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerGroupPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PartnerGroupFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerGroupPayload>
        }
        findFirst: {
          args: Prisma.PartnerGroupFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerGroupPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PartnerGroupFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerGroupPayload>
        }
        findMany: {
          args: Prisma.PartnerGroupFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerGroupPayload>[]
        }
        create: {
          args: Prisma.PartnerGroupCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerGroupPayload>
        }
        createMany: {
          args: Prisma.PartnerGroupCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.PartnerGroupDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerGroupPayload>
        }
        update: {
          args: Prisma.PartnerGroupUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerGroupPayload>
        }
        deleteMany: {
          args: Prisma.PartnerGroupDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PartnerGroupUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.PartnerGroupUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerGroupPayload>
        }
        aggregate: {
          args: Prisma.PartnerGroupAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePartnerGroup>
        }
        groupBy: {
          args: Prisma.PartnerGroupGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PartnerGroupGroupByOutputType>[]
        }
        count: {
          args: Prisma.PartnerGroupCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PartnerGroupCountAggregateOutputType> | number
        }
      }
    }
    PartnerGroupDefaultLink: {
      payload: Prisma.$PartnerGroupDefaultLinkPayload<ExtArgs>
      fields: Prisma.PartnerGroupDefaultLinkFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PartnerGroupDefaultLinkFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerGroupDefaultLinkPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PartnerGroupDefaultLinkFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerGroupDefaultLinkPayload>
        }
        findFirst: {
          args: Prisma.PartnerGroupDefaultLinkFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerGroupDefaultLinkPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PartnerGroupDefaultLinkFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerGroupDefaultLinkPayload>
        }
        findMany: {
          args: Prisma.PartnerGroupDefaultLinkFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerGroupDefaultLinkPayload>[]
        }
        create: {
          args: Prisma.PartnerGroupDefaultLinkCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerGroupDefaultLinkPayload>
        }
        createMany: {
          args: Prisma.PartnerGroupDefaultLinkCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.PartnerGroupDefaultLinkDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerGroupDefaultLinkPayload>
        }
        update: {
          args: Prisma.PartnerGroupDefaultLinkUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerGroupDefaultLinkPayload>
        }
        deleteMany: {
          args: Prisma.PartnerGroupDefaultLinkDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PartnerGroupDefaultLinkUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.PartnerGroupDefaultLinkUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerGroupDefaultLinkPayload>
        }
        aggregate: {
          args: Prisma.PartnerGroupDefaultLinkAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePartnerGroupDefaultLink>
        }
        groupBy: {
          args: Prisma.PartnerGroupDefaultLinkGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PartnerGroupDefaultLinkGroupByOutputType>[]
        }
        count: {
          args: Prisma.PartnerGroupDefaultLinkCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PartnerGroupDefaultLinkCountAggregateOutputType> | number
        }
      }
    }
    Integration: {
      payload: Prisma.$IntegrationPayload<ExtArgs>
      fields: Prisma.IntegrationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.IntegrationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IntegrationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.IntegrationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IntegrationPayload>
        }
        findFirst: {
          args: Prisma.IntegrationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IntegrationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.IntegrationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IntegrationPayload>
        }
        findMany: {
          args: Prisma.IntegrationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IntegrationPayload>[]
        }
        create: {
          args: Prisma.IntegrationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IntegrationPayload>
        }
        createMany: {
          args: Prisma.IntegrationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.IntegrationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IntegrationPayload>
        }
        update: {
          args: Prisma.IntegrationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IntegrationPayload>
        }
        deleteMany: {
          args: Prisma.IntegrationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.IntegrationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.IntegrationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IntegrationPayload>
        }
        aggregate: {
          args: Prisma.IntegrationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateIntegration>
        }
        groupBy: {
          args: Prisma.IntegrationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.IntegrationGroupByOutputType>[]
        }
        count: {
          args: Prisma.IntegrationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.IntegrationCountAggregateOutputType> | number
        }
      }
    }
    InstalledIntegration: {
      payload: Prisma.$InstalledIntegrationPayload<ExtArgs>
      fields: Prisma.InstalledIntegrationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.InstalledIntegrationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstalledIntegrationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.InstalledIntegrationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstalledIntegrationPayload>
        }
        findFirst: {
          args: Prisma.InstalledIntegrationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstalledIntegrationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.InstalledIntegrationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstalledIntegrationPayload>
        }
        findMany: {
          args: Prisma.InstalledIntegrationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstalledIntegrationPayload>[]
        }
        create: {
          args: Prisma.InstalledIntegrationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstalledIntegrationPayload>
        }
        createMany: {
          args: Prisma.InstalledIntegrationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.InstalledIntegrationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstalledIntegrationPayload>
        }
        update: {
          args: Prisma.InstalledIntegrationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstalledIntegrationPayload>
        }
        deleteMany: {
          args: Prisma.InstalledIntegrationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.InstalledIntegrationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.InstalledIntegrationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstalledIntegrationPayload>
        }
        aggregate: {
          args: Prisma.InstalledIntegrationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateInstalledIntegration>
        }
        groupBy: {
          args: Prisma.InstalledIntegrationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InstalledIntegrationGroupByOutputType>[]
        }
        count: {
          args: Prisma.InstalledIntegrationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InstalledIntegrationCountAggregateOutputType> | number
        }
      }
    }
    Invoice: {
      payload: Prisma.$InvoicePayload<ExtArgs>
      fields: Prisma.InvoiceFieldRefs
      operations: {
        findUnique: {
          args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>
        }
        findFirst: {
          args: Prisma.InvoiceFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>
        }
        findMany: {
          args: Prisma.InvoiceFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>[]
        }
        create: {
          args: Prisma.InvoiceCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>
        }
        createMany: {
          args: Prisma.InvoiceCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.InvoiceDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>
        }
        update: {
          args: Prisma.InvoiceUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>
        }
        deleteMany: {
          args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.InvoiceUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>
        }
        aggregate: {
          args: Prisma.InvoiceAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateInvoice>
        }
        groupBy: {
          args: Prisma.InvoiceGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InvoiceGroupByOutputType>[]
        }
        count: {
          args: Prisma.InvoiceCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InvoiceCountAggregateOutputType> | number
        }
      }
    }
    jackson_index: {
      payload: Prisma.$jackson_indexPayload<ExtArgs>
      fields: Prisma.jackson_indexFieldRefs
      operations: {
        findUnique: {
          args: Prisma.jackson_indexFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$jackson_indexPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.jackson_indexFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$jackson_indexPayload>
        }
        findFirst: {
          args: Prisma.jackson_indexFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$jackson_indexPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.jackson_indexFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$jackson_indexPayload>
        }
        findMany: {
          args: Prisma.jackson_indexFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$jackson_indexPayload>[]
        }
        create: {
          args: Prisma.jackson_indexCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$jackson_indexPayload>
        }
        createMany: {
          args: Prisma.jackson_indexCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.jackson_indexDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$jackson_indexPayload>
        }
        update: {
          args: Prisma.jackson_indexUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$jackson_indexPayload>
        }
        deleteMany: {
          args: Prisma.jackson_indexDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.jackson_indexUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.jackson_indexUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$jackson_indexPayload>
        }
        aggregate: {
          args: Prisma.Jackson_indexAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateJackson_index>
        }
        groupBy: {
          args: Prisma.jackson_indexGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Jackson_indexGroupByOutputType>[]
        }
        count: {
          args: Prisma.jackson_indexCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Jackson_indexCountAggregateOutputType> | number
        }
      }
    }
    jackson_store: {
      payload: Prisma.$jackson_storePayload<ExtArgs>
      fields: Prisma.jackson_storeFieldRefs
      operations: {
        findUnique: {
          args: Prisma.jackson_storeFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$jackson_storePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.jackson_storeFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$jackson_storePayload>
        }
        findFirst: {
          args: Prisma.jackson_storeFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$jackson_storePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.jackson_storeFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$jackson_storePayload>
        }
        findMany: {
          args: Prisma.jackson_storeFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$jackson_storePayload>[]
        }
        create: {
          args: Prisma.jackson_storeCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$jackson_storePayload>
        }
        createMany: {
          args: Prisma.jackson_storeCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.jackson_storeDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$jackson_storePayload>
        }
        update: {
          args: Prisma.jackson_storeUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$jackson_storePayload>
        }
        deleteMany: {
          args: Prisma.jackson_storeDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.jackson_storeUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.jackson_storeUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$jackson_storePayload>
        }
        aggregate: {
          args: Prisma.Jackson_storeAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateJackson_store>
        }
        groupBy: {
          args: Prisma.jackson_storeGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Jackson_storeGroupByOutputType>[]
        }
        count: {
          args: Prisma.jackson_storeCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Jackson_storeCountAggregateOutputType> | number
        }
      }
    }
    jackson_ttl: {
      payload: Prisma.$jackson_ttlPayload<ExtArgs>
      fields: Prisma.jackson_ttlFieldRefs
      operations: {
        findUnique: {
          args: Prisma.jackson_ttlFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$jackson_ttlPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.jackson_ttlFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$jackson_ttlPayload>
        }
        findFirst: {
          args: Prisma.jackson_ttlFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$jackson_ttlPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.jackson_ttlFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$jackson_ttlPayload>
        }
        findMany: {
          args: Prisma.jackson_ttlFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$jackson_ttlPayload>[]
        }
        create: {
          args: Prisma.jackson_ttlCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$jackson_ttlPayload>
        }
        createMany: {
          args: Prisma.jackson_ttlCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.jackson_ttlDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$jackson_ttlPayload>
        }
        update: {
          args: Prisma.jackson_ttlUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$jackson_ttlPayload>
        }
        deleteMany: {
          args: Prisma.jackson_ttlDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.jackson_ttlUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.jackson_ttlUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$jackson_ttlPayload>
        }
        aggregate: {
          args: Prisma.Jackson_ttlAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateJackson_ttl>
        }
        groupBy: {
          args: Prisma.jackson_ttlGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Jackson_ttlGroupByOutputType>[]
        }
        count: {
          args: Prisma.jackson_ttlCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Jackson_ttlCountAggregateOutputType> | number
        }
      }
    }
    Link: {
      payload: Prisma.$LinkPayload<ExtArgs>
      fields: Prisma.LinkFieldRefs
      operations: {
        findUnique: {
          args: Prisma.LinkFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LinkPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.LinkFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LinkPayload>
        }
        findFirst: {
          args: Prisma.LinkFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LinkPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.LinkFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LinkPayload>
        }
        findMany: {
          args: Prisma.LinkFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LinkPayload>[]
        }
        create: {
          args: Prisma.LinkCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LinkPayload>
        }
        createMany: {
          args: Prisma.LinkCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.LinkDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LinkPayload>
        }
        update: {
          args: Prisma.LinkUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LinkPayload>
        }
        deleteMany: {
          args: Prisma.LinkDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.LinkUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.LinkUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LinkPayload>
        }
        aggregate: {
          args: Prisma.LinkAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateLink>
        }
        groupBy: {
          args: Prisma.LinkGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LinkGroupByOutputType>[]
        }
        count: {
          args: Prisma.LinkCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LinkCountAggregateOutputType> | number
        }
      }
    }
    Message: {
      payload: Prisma.$MessagePayload<ExtArgs>
      fields: Prisma.MessageFieldRefs
      operations: {
        findUnique: {
          args: Prisma.MessageFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>
        }
        findFirst: {
          args: Prisma.MessageFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>
        }
        findMany: {
          args: Prisma.MessageFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>[]
        }
        create: {
          args: Prisma.MessageCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>
        }
        createMany: {
          args: Prisma.MessageCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.MessageDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>
        }
        update: {
          args: Prisma.MessageUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>
        }
        deleteMany: {
          args: Prisma.MessageDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.MessageUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.MessageUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>
        }
        aggregate: {
          args: Prisma.MessageAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateMessage>
        }
        groupBy: {
          args: Prisma.MessageGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MessageGroupByOutputType>[]
        }
        count: {
          args: Prisma.MessageCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MessageCountAggregateOutputType> | number
        }
      }
    }
    YearInReview: {
      payload: Prisma.$YearInReviewPayload<ExtArgs>
      fields: Prisma.YearInReviewFieldRefs
      operations: {
        findUnique: {
          args: Prisma.YearInReviewFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$YearInReviewPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.YearInReviewFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$YearInReviewPayload>
        }
        findFirst: {
          args: Prisma.YearInReviewFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$YearInReviewPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.YearInReviewFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$YearInReviewPayload>
        }
        findMany: {
          args: Prisma.YearInReviewFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$YearInReviewPayload>[]
        }
        create: {
          args: Prisma.YearInReviewCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$YearInReviewPayload>
        }
        createMany: {
          args: Prisma.YearInReviewCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.YearInReviewDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$YearInReviewPayload>
        }
        update: {
          args: Prisma.YearInReviewUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$YearInReviewPayload>
        }
        deleteMany: {
          args: Prisma.YearInReviewDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.YearInReviewUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.YearInReviewUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$YearInReviewPayload>
        }
        aggregate: {
          args: Prisma.YearInReviewAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateYearInReview>
        }
        groupBy: {
          args: Prisma.YearInReviewGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.YearInReviewGroupByOutputType>[]
        }
        count: {
          args: Prisma.YearInReviewCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.YearInReviewCountAggregateOutputType> | number
        }
      }
    }
    PartnerRewind: {
      payload: Prisma.$PartnerRewindPayload<ExtArgs>
      fields: Prisma.PartnerRewindFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PartnerRewindFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerRewindPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PartnerRewindFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerRewindPayload>
        }
        findFirst: {
          args: Prisma.PartnerRewindFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerRewindPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PartnerRewindFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerRewindPayload>
        }
        findMany: {
          args: Prisma.PartnerRewindFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerRewindPayload>[]
        }
        create: {
          args: Prisma.PartnerRewindCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerRewindPayload>
        }
        createMany: {
          args: Prisma.PartnerRewindCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.PartnerRewindDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerRewindPayload>
        }
        update: {
          args: Prisma.PartnerRewindUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerRewindPayload>
        }
        deleteMany: {
          args: Prisma.PartnerRewindDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PartnerRewindUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.PartnerRewindUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerRewindPayload>
        }
        aggregate: {
          args: Prisma.PartnerRewindAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePartnerRewind>
        }
        groupBy: {
          args: Prisma.PartnerRewindGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PartnerRewindGroupByOutputType>[]
        }
        count: {
          args: Prisma.PartnerRewindCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PartnerRewindCountAggregateOutputType> | number
        }
      }
    }
    ProgramCategory: {
      payload: Prisma.$ProgramCategoryPayload<ExtArgs>
      fields: Prisma.ProgramCategoryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ProgramCategoryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramCategoryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ProgramCategoryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramCategoryPayload>
        }
        findFirst: {
          args: Prisma.ProgramCategoryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramCategoryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ProgramCategoryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramCategoryPayload>
        }
        findMany: {
          args: Prisma.ProgramCategoryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramCategoryPayload>[]
        }
        create: {
          args: Prisma.ProgramCategoryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramCategoryPayload>
        }
        createMany: {
          args: Prisma.ProgramCategoryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.ProgramCategoryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramCategoryPayload>
        }
        update: {
          args: Prisma.ProgramCategoryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramCategoryPayload>
        }
        deleteMany: {
          args: Prisma.ProgramCategoryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ProgramCategoryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.ProgramCategoryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramCategoryPayload>
        }
        aggregate: {
          args: Prisma.ProgramCategoryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProgramCategory>
        }
        groupBy: {
          args: Prisma.ProgramCategoryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProgramCategoryGroupByOutputType>[]
        }
        count: {
          args: Prisma.ProgramCategoryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProgramCategoryCountAggregateOutputType> | number
        }
      }
    }
    ProgramSimilarity: {
      payload: Prisma.$ProgramSimilarityPayload<ExtArgs>
      fields: Prisma.ProgramSimilarityFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ProgramSimilarityFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramSimilarityPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ProgramSimilarityFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramSimilarityPayload>
        }
        findFirst: {
          args: Prisma.ProgramSimilarityFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramSimilarityPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ProgramSimilarityFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramSimilarityPayload>
        }
        findMany: {
          args: Prisma.ProgramSimilarityFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramSimilarityPayload>[]
        }
        create: {
          args: Prisma.ProgramSimilarityCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramSimilarityPayload>
        }
        createMany: {
          args: Prisma.ProgramSimilarityCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.ProgramSimilarityDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramSimilarityPayload>
        }
        update: {
          args: Prisma.ProgramSimilarityUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramSimilarityPayload>
        }
        deleteMany: {
          args: Prisma.ProgramSimilarityDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ProgramSimilarityUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.ProgramSimilarityUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramSimilarityPayload>
        }
        aggregate: {
          args: Prisma.ProgramSimilarityAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProgramSimilarity>
        }
        groupBy: {
          args: Prisma.ProgramSimilarityGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProgramSimilarityGroupByOutputType>[]
        }
        count: {
          args: Prisma.ProgramSimilarityCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProgramSimilarityCountAggregateOutputType> | number
        }
      }
    }
    DiscoveredPartner: {
      payload: Prisma.$DiscoveredPartnerPayload<ExtArgs>
      fields: Prisma.DiscoveredPartnerFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DiscoveredPartnerFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscoveredPartnerPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DiscoveredPartnerFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscoveredPartnerPayload>
        }
        findFirst: {
          args: Prisma.DiscoveredPartnerFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscoveredPartnerPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DiscoveredPartnerFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscoveredPartnerPayload>
        }
        findMany: {
          args: Prisma.DiscoveredPartnerFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscoveredPartnerPayload>[]
        }
        create: {
          args: Prisma.DiscoveredPartnerCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscoveredPartnerPayload>
        }
        createMany: {
          args: Prisma.DiscoveredPartnerCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.DiscoveredPartnerDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscoveredPartnerPayload>
        }
        update: {
          args: Prisma.DiscoveredPartnerUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscoveredPartnerPayload>
        }
        deleteMany: {
          args: Prisma.DiscoveredPartnerDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DiscoveredPartnerUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.DiscoveredPartnerUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscoveredPartnerPayload>
        }
        aggregate: {
          args: Prisma.DiscoveredPartnerAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDiscoveredPartner>
        }
        groupBy: {
          args: Prisma.DiscoveredPartnerGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DiscoveredPartnerGroupByOutputType>[]
        }
        count: {
          args: Prisma.DiscoveredPartnerCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DiscoveredPartnerCountAggregateOutputType> | number
        }
      }
    }
    NotificationEmail: {
      payload: Prisma.$NotificationEmailPayload<ExtArgs>
      fields: Prisma.NotificationEmailFieldRefs
      operations: {
        findUnique: {
          args: Prisma.NotificationEmailFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationEmailPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.NotificationEmailFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationEmailPayload>
        }
        findFirst: {
          args: Prisma.NotificationEmailFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationEmailPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.NotificationEmailFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationEmailPayload>
        }
        findMany: {
          args: Prisma.NotificationEmailFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationEmailPayload>[]
        }
        create: {
          args: Prisma.NotificationEmailCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationEmailPayload>
        }
        createMany: {
          args: Prisma.NotificationEmailCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.NotificationEmailDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationEmailPayload>
        }
        update: {
          args: Prisma.NotificationEmailUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationEmailPayload>
        }
        deleteMany: {
          args: Prisma.NotificationEmailDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.NotificationEmailUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.NotificationEmailUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationEmailPayload>
        }
        aggregate: {
          args: Prisma.NotificationEmailAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateNotificationEmail>
        }
        groupBy: {
          args: Prisma.NotificationEmailGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NotificationEmailGroupByOutputType>[]
        }
        count: {
          args: Prisma.NotificationEmailCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NotificationEmailCountAggregateOutputType> | number
        }
      }
    }
    NotificationPreference: {
      payload: Prisma.$NotificationPreferencePayload<ExtArgs>
      fields: Prisma.NotificationPreferenceFieldRefs
      operations: {
        findUnique: {
          args: Prisma.NotificationPreferenceFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPreferencePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.NotificationPreferenceFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
        }
        findFirst: {
          args: Prisma.NotificationPreferenceFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPreferencePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.NotificationPreferenceFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
        }
        findMany: {
          args: Prisma.NotificationPreferenceFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>[]
        }
        create: {
          args: Prisma.NotificationPreferenceCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
        }
        createMany: {
          args: Prisma.NotificationPreferenceCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.NotificationPreferenceDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
        }
        update: {
          args: Prisma.NotificationPreferenceUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
        }
        deleteMany: {
          args: Prisma.NotificationPreferenceDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.NotificationPreferenceUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.NotificationPreferenceUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
        }
        aggregate: {
          args: Prisma.NotificationPreferenceAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateNotificationPreference>
        }
        groupBy: {
          args: Prisma.NotificationPreferenceGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NotificationPreferenceGroupByOutputType>[]
        }
        count: {
          args: Prisma.NotificationPreferenceCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NotificationPreferenceCountAggregateOutputType> | number
        }
      }
    }
    PartnerNotificationPreferences: {
      payload: Prisma.$PartnerNotificationPreferencesPayload<ExtArgs>
      fields: Prisma.PartnerNotificationPreferencesFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PartnerNotificationPreferencesFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerNotificationPreferencesPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PartnerNotificationPreferencesFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerNotificationPreferencesPayload>
        }
        findFirst: {
          args: Prisma.PartnerNotificationPreferencesFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerNotificationPreferencesPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PartnerNotificationPreferencesFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerNotificationPreferencesPayload>
        }
        findMany: {
          args: Prisma.PartnerNotificationPreferencesFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerNotificationPreferencesPayload>[]
        }
        create: {
          args: Prisma.PartnerNotificationPreferencesCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerNotificationPreferencesPayload>
        }
        createMany: {
          args: Prisma.PartnerNotificationPreferencesCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.PartnerNotificationPreferencesDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerNotificationPreferencesPayload>
        }
        update: {
          args: Prisma.PartnerNotificationPreferencesUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerNotificationPreferencesPayload>
        }
        deleteMany: {
          args: Prisma.PartnerNotificationPreferencesDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PartnerNotificationPreferencesUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.PartnerNotificationPreferencesUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerNotificationPreferencesPayload>
        }
        aggregate: {
          args: Prisma.PartnerNotificationPreferencesAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePartnerNotificationPreferences>
        }
        groupBy: {
          args: Prisma.PartnerNotificationPreferencesGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PartnerNotificationPreferencesGroupByOutputType>[]
        }
        count: {
          args: Prisma.PartnerNotificationPreferencesCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PartnerNotificationPreferencesCountAggregateOutputType> | number
        }
      }
    }
    OAuthApp: {
      payload: Prisma.$OAuthAppPayload<ExtArgs>
      fields: Prisma.OAuthAppFieldRefs
      operations: {
        findUnique: {
          args: Prisma.OAuthAppFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OAuthAppPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.OAuthAppFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OAuthAppPayload>
        }
        findFirst: {
          args: Prisma.OAuthAppFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OAuthAppPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.OAuthAppFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OAuthAppPayload>
        }
        findMany: {
          args: Prisma.OAuthAppFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OAuthAppPayload>[]
        }
        create: {
          args: Prisma.OAuthAppCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OAuthAppPayload>
        }
        createMany: {
          args: Prisma.OAuthAppCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.OAuthAppDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OAuthAppPayload>
        }
        update: {
          args: Prisma.OAuthAppUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OAuthAppPayload>
        }
        deleteMany: {
          args: Prisma.OAuthAppDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.OAuthAppUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.OAuthAppUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OAuthAppPayload>
        }
        aggregate: {
          args: Prisma.OAuthAppAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateOAuthApp>
        }
        groupBy: {
          args: Prisma.OAuthAppGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OAuthAppGroupByOutputType>[]
        }
        count: {
          args: Prisma.OAuthAppCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OAuthAppCountAggregateOutputType> | number
        }
      }
    }
    OAuthCode: {
      payload: Prisma.$OAuthCodePayload<ExtArgs>
      fields: Prisma.OAuthCodeFieldRefs
      operations: {
        findUnique: {
          args: Prisma.OAuthCodeFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OAuthCodePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.OAuthCodeFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OAuthCodePayload>
        }
        findFirst: {
          args: Prisma.OAuthCodeFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OAuthCodePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.OAuthCodeFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OAuthCodePayload>
        }
        findMany: {
          args: Prisma.OAuthCodeFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OAuthCodePayload>[]
        }
        create: {
          args: Prisma.OAuthCodeCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OAuthCodePayload>
        }
        createMany: {
          args: Prisma.OAuthCodeCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.OAuthCodeDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OAuthCodePayload>
        }
        update: {
          args: Prisma.OAuthCodeUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OAuthCodePayload>
        }
        deleteMany: {
          args: Prisma.OAuthCodeDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.OAuthCodeUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.OAuthCodeUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OAuthCodePayload>
        }
        aggregate: {
          args: Prisma.OAuthCodeAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateOAuthCode>
        }
        groupBy: {
          args: Prisma.OAuthCodeGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OAuthCodeGroupByOutputType>[]
        }
        count: {
          args: Prisma.OAuthCodeCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OAuthCodeCountAggregateOutputType> | number
        }
      }
    }
    OAuthRefreshToken: {
      payload: Prisma.$OAuthRefreshTokenPayload<ExtArgs>
      fields: Prisma.OAuthRefreshTokenFieldRefs
      operations: {
        findUnique: {
          args: Prisma.OAuthRefreshTokenFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OAuthRefreshTokenPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.OAuthRefreshTokenFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OAuthRefreshTokenPayload>
        }
        findFirst: {
          args: Prisma.OAuthRefreshTokenFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OAuthRefreshTokenPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.OAuthRefreshTokenFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OAuthRefreshTokenPayload>
        }
        findMany: {
          args: Prisma.OAuthRefreshTokenFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OAuthRefreshTokenPayload>[]
        }
        create: {
          args: Prisma.OAuthRefreshTokenCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OAuthRefreshTokenPayload>
        }
        createMany: {
          args: Prisma.OAuthRefreshTokenCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.OAuthRefreshTokenDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OAuthRefreshTokenPayload>
        }
        update: {
          args: Prisma.OAuthRefreshTokenUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OAuthRefreshTokenPayload>
        }
        deleteMany: {
          args: Prisma.OAuthRefreshTokenDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.OAuthRefreshTokenUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.OAuthRefreshTokenUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OAuthRefreshTokenPayload>
        }
        aggregate: {
          args: Prisma.OAuthRefreshTokenAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateOAuthRefreshToken>
        }
        groupBy: {
          args: Prisma.OAuthRefreshTokenGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OAuthRefreshTokenGroupByOutputType>[]
        }
        count: {
          args: Prisma.OAuthRefreshTokenCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OAuthRefreshTokenCountAggregateOutputType> | number
        }
      }
    }
    Partner: {
      payload: Prisma.$PartnerPayload<ExtArgs>
      fields: Prisma.PartnerFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PartnerFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PartnerFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerPayload>
        }
        findFirst: {
          args: Prisma.PartnerFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PartnerFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerPayload>
        }
        findMany: {
          args: Prisma.PartnerFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerPayload>[]
        }
        create: {
          args: Prisma.PartnerCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerPayload>
        }
        createMany: {
          args: Prisma.PartnerCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.PartnerDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerPayload>
        }
        update: {
          args: Prisma.PartnerUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerPayload>
        }
        deleteMany: {
          args: Prisma.PartnerDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PartnerUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.PartnerUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerPayload>
        }
        aggregate: {
          args: Prisma.PartnerAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePartner>
        }
        groupBy: {
          args: Prisma.PartnerGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PartnerGroupByOutputType>[]
        }
        count: {
          args: Prisma.PartnerCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PartnerCountAggregateOutputType> | number
        }
      }
    }
    PartnerInvite: {
      payload: Prisma.$PartnerInvitePayload<ExtArgs>
      fields: Prisma.PartnerInviteFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PartnerInviteFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerInvitePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PartnerInviteFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerInvitePayload>
        }
        findFirst: {
          args: Prisma.PartnerInviteFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerInvitePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PartnerInviteFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerInvitePayload>
        }
        findMany: {
          args: Prisma.PartnerInviteFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerInvitePayload>[]
        }
        create: {
          args: Prisma.PartnerInviteCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerInvitePayload>
        }
        createMany: {
          args: Prisma.PartnerInviteCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.PartnerInviteDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerInvitePayload>
        }
        update: {
          args: Prisma.PartnerInviteUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerInvitePayload>
        }
        deleteMany: {
          args: Prisma.PartnerInviteDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PartnerInviteUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.PartnerInviteUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerInvitePayload>
        }
        aggregate: {
          args: Prisma.PartnerInviteAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePartnerInvite>
        }
        groupBy: {
          args: Prisma.PartnerInviteGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PartnerInviteGroupByOutputType>[]
        }
        count: {
          args: Prisma.PartnerInviteCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PartnerInviteCountAggregateOutputType> | number
        }
      }
    }
    PartnerUser: {
      payload: Prisma.$PartnerUserPayload<ExtArgs>
      fields: Prisma.PartnerUserFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PartnerUserFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerUserPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PartnerUserFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerUserPayload>
        }
        findFirst: {
          args: Prisma.PartnerUserFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerUserPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PartnerUserFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerUserPayload>
        }
        findMany: {
          args: Prisma.PartnerUserFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerUserPayload>[]
        }
        create: {
          args: Prisma.PartnerUserCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerUserPayload>
        }
        createMany: {
          args: Prisma.PartnerUserCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.PartnerUserDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerUserPayload>
        }
        update: {
          args: Prisma.PartnerUserUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerUserPayload>
        }
        deleteMany: {
          args: Prisma.PartnerUserDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PartnerUserUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.PartnerUserUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerUserPayload>
        }
        aggregate: {
          args: Prisma.PartnerUserAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePartnerUser>
        }
        groupBy: {
          args: Prisma.PartnerUserGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PartnerUserGroupByOutputType>[]
        }
        count: {
          args: Prisma.PartnerUserCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PartnerUserCountAggregateOutputType> | number
        }
      }
    }
    PartnerIndustryInterest: {
      payload: Prisma.$PartnerIndustryInterestPayload<ExtArgs>
      fields: Prisma.PartnerIndustryInterestFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PartnerIndustryInterestFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerIndustryInterestPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PartnerIndustryInterestFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerIndustryInterestPayload>
        }
        findFirst: {
          args: Prisma.PartnerIndustryInterestFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerIndustryInterestPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PartnerIndustryInterestFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerIndustryInterestPayload>
        }
        findMany: {
          args: Prisma.PartnerIndustryInterestFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerIndustryInterestPayload>[]
        }
        create: {
          args: Prisma.PartnerIndustryInterestCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerIndustryInterestPayload>
        }
        createMany: {
          args: Prisma.PartnerIndustryInterestCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.PartnerIndustryInterestDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerIndustryInterestPayload>
        }
        update: {
          args: Prisma.PartnerIndustryInterestUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerIndustryInterestPayload>
        }
        deleteMany: {
          args: Prisma.PartnerIndustryInterestDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PartnerIndustryInterestUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.PartnerIndustryInterestUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerIndustryInterestPayload>
        }
        aggregate: {
          args: Prisma.PartnerIndustryInterestAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePartnerIndustryInterest>
        }
        groupBy: {
          args: Prisma.PartnerIndustryInterestGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PartnerIndustryInterestGroupByOutputType>[]
        }
        count: {
          args: Prisma.PartnerIndustryInterestCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PartnerIndustryInterestCountAggregateOutputType> | number
        }
      }
    }
    PartnerPreferredEarningStructure: {
      payload: Prisma.$PartnerPreferredEarningStructurePayload<ExtArgs>
      fields: Prisma.PartnerPreferredEarningStructureFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PartnerPreferredEarningStructureFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerPreferredEarningStructurePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PartnerPreferredEarningStructureFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerPreferredEarningStructurePayload>
        }
        findFirst: {
          args: Prisma.PartnerPreferredEarningStructureFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerPreferredEarningStructurePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PartnerPreferredEarningStructureFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerPreferredEarningStructurePayload>
        }
        findMany: {
          args: Prisma.PartnerPreferredEarningStructureFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerPreferredEarningStructurePayload>[]
        }
        create: {
          args: Prisma.PartnerPreferredEarningStructureCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerPreferredEarningStructurePayload>
        }
        createMany: {
          args: Prisma.PartnerPreferredEarningStructureCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.PartnerPreferredEarningStructureDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerPreferredEarningStructurePayload>
        }
        update: {
          args: Prisma.PartnerPreferredEarningStructureUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerPreferredEarningStructurePayload>
        }
        deleteMany: {
          args: Prisma.PartnerPreferredEarningStructureDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PartnerPreferredEarningStructureUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.PartnerPreferredEarningStructureUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerPreferredEarningStructurePayload>
        }
        aggregate: {
          args: Prisma.PartnerPreferredEarningStructureAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePartnerPreferredEarningStructure>
        }
        groupBy: {
          args: Prisma.PartnerPreferredEarningStructureGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PartnerPreferredEarningStructureGroupByOutputType>[]
        }
        count: {
          args: Prisma.PartnerPreferredEarningStructureCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PartnerPreferredEarningStructureCountAggregateOutputType> | number
        }
      }
    }
    PartnerSalesChannel: {
      payload: Prisma.$PartnerSalesChannelPayload<ExtArgs>
      fields: Prisma.PartnerSalesChannelFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PartnerSalesChannelFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerSalesChannelPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PartnerSalesChannelFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerSalesChannelPayload>
        }
        findFirst: {
          args: Prisma.PartnerSalesChannelFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerSalesChannelPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PartnerSalesChannelFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerSalesChannelPayload>
        }
        findMany: {
          args: Prisma.PartnerSalesChannelFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerSalesChannelPayload>[]
        }
        create: {
          args: Prisma.PartnerSalesChannelCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerSalesChannelPayload>
        }
        createMany: {
          args: Prisma.PartnerSalesChannelCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.PartnerSalesChannelDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerSalesChannelPayload>
        }
        update: {
          args: Prisma.PartnerSalesChannelUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerSalesChannelPayload>
        }
        deleteMany: {
          args: Prisma.PartnerSalesChannelDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PartnerSalesChannelUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.PartnerSalesChannelUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerSalesChannelPayload>
        }
        aggregate: {
          args: Prisma.PartnerSalesChannelAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePartnerSalesChannel>
        }
        groupBy: {
          args: Prisma.PartnerSalesChannelGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PartnerSalesChannelGroupByOutputType>[]
        }
        count: {
          args: Prisma.PartnerSalesChannelCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PartnerSalesChannelCountAggregateOutputType> | number
        }
      }
    }
    Payout: {
      payload: Prisma.$PayoutPayload<ExtArgs>
      fields: Prisma.PayoutFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PayoutFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayoutPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PayoutFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayoutPayload>
        }
        findFirst: {
          args: Prisma.PayoutFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayoutPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PayoutFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayoutPayload>
        }
        findMany: {
          args: Prisma.PayoutFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayoutPayload>[]
        }
        create: {
          args: Prisma.PayoutCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayoutPayload>
        }
        createMany: {
          args: Prisma.PayoutCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.PayoutDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayoutPayload>
        }
        update: {
          args: Prisma.PayoutUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayoutPayload>
        }
        deleteMany: {
          args: Prisma.PayoutDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PayoutUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.PayoutUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayoutPayload>
        }
        aggregate: {
          args: Prisma.PayoutAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePayout>
        }
        groupBy: {
          args: Prisma.PayoutGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PayoutGroupByOutputType>[]
        }
        count: {
          args: Prisma.PayoutCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PayoutCountAggregateOutputType> | number
        }
      }
    }
    Program: {
      payload: Prisma.$ProgramPayload<ExtArgs>
      fields: Prisma.ProgramFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ProgramFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ProgramFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramPayload>
        }
        findFirst: {
          args: Prisma.ProgramFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ProgramFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramPayload>
        }
        findMany: {
          args: Prisma.ProgramFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramPayload>[]
        }
        create: {
          args: Prisma.ProgramCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramPayload>
        }
        createMany: {
          args: Prisma.ProgramCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.ProgramDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramPayload>
        }
        update: {
          args: Prisma.ProgramUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramPayload>
        }
        deleteMany: {
          args: Prisma.ProgramDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ProgramUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.ProgramUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramPayload>
        }
        aggregate: {
          args: Prisma.ProgramAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProgram>
        }
        groupBy: {
          args: Prisma.ProgramGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProgramGroupByOutputType>[]
        }
        count: {
          args: Prisma.ProgramCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProgramCountAggregateOutputType> | number
        }
      }
    }
    ProgramEnrollment: {
      payload: Prisma.$ProgramEnrollmentPayload<ExtArgs>
      fields: Prisma.ProgramEnrollmentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ProgramEnrollmentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramEnrollmentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ProgramEnrollmentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramEnrollmentPayload>
        }
        findFirst: {
          args: Prisma.ProgramEnrollmentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramEnrollmentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ProgramEnrollmentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramEnrollmentPayload>
        }
        findMany: {
          args: Prisma.ProgramEnrollmentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramEnrollmentPayload>[]
        }
        create: {
          args: Prisma.ProgramEnrollmentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramEnrollmentPayload>
        }
        createMany: {
          args: Prisma.ProgramEnrollmentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.ProgramEnrollmentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramEnrollmentPayload>
        }
        update: {
          args: Prisma.ProgramEnrollmentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramEnrollmentPayload>
        }
        deleteMany: {
          args: Prisma.ProgramEnrollmentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ProgramEnrollmentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.ProgramEnrollmentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramEnrollmentPayload>
        }
        aggregate: {
          args: Prisma.ProgramEnrollmentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProgramEnrollment>
        }
        groupBy: {
          args: Prisma.ProgramEnrollmentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProgramEnrollmentGroupByOutputType>[]
        }
        count: {
          args: Prisma.ProgramEnrollmentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProgramEnrollmentCountAggregateOutputType> | number
        }
      }
    }
    ProgramApplication: {
      payload: Prisma.$ProgramApplicationPayload<ExtArgs>
      fields: Prisma.ProgramApplicationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ProgramApplicationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramApplicationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ProgramApplicationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramApplicationPayload>
        }
        findFirst: {
          args: Prisma.ProgramApplicationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramApplicationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ProgramApplicationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramApplicationPayload>
        }
        findMany: {
          args: Prisma.ProgramApplicationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramApplicationPayload>[]
        }
        create: {
          args: Prisma.ProgramApplicationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramApplicationPayload>
        }
        createMany: {
          args: Prisma.ProgramApplicationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.ProgramApplicationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramApplicationPayload>
        }
        update: {
          args: Prisma.ProgramApplicationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramApplicationPayload>
        }
        deleteMany: {
          args: Prisma.ProgramApplicationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ProgramApplicationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.ProgramApplicationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramApplicationPayload>
        }
        aggregate: {
          args: Prisma.ProgramApplicationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProgramApplication>
        }
        groupBy: {
          args: Prisma.ProgramApplicationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProgramApplicationGroupByOutputType>[]
        }
        count: {
          args: Prisma.ProgramApplicationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProgramApplicationCountAggregateOutputType> | number
        }
      }
    }
    Reward: {
      payload: Prisma.$RewardPayload<ExtArgs>
      fields: Prisma.RewardFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RewardFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RewardPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RewardFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RewardPayload>
        }
        findFirst: {
          args: Prisma.RewardFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RewardPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RewardFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RewardPayload>
        }
        findMany: {
          args: Prisma.RewardFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RewardPayload>[]
        }
        create: {
          args: Prisma.RewardCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RewardPayload>
        }
        createMany: {
          args: Prisma.RewardCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.RewardDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RewardPayload>
        }
        update: {
          args: Prisma.RewardUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RewardPayload>
        }
        deleteMany: {
          args: Prisma.RewardDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RewardUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.RewardUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RewardPayload>
        }
        aggregate: {
          args: Prisma.RewardAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateReward>
        }
        groupBy: {
          args: Prisma.RewardGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RewardGroupByOutputType>[]
        }
        count: {
          args: Prisma.RewardCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RewardCountAggregateOutputType> | number
        }
      }
    }
    User: {
      payload: Prisma.$UserPayload<ExtArgs>
      fields: Prisma.UserFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UserFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        findFirst: {
          args: Prisma.UserFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        findMany: {
          args: Prisma.UserFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]
        }
        create: {
          args: Prisma.UserCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        createMany: {
          args: Prisma.UserCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.UserDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        update: {
          args: Prisma.UserUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        deleteMany: {
          args: Prisma.UserDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UserUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.UserUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        aggregate: {
          args: Prisma.UserAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUser>
        }
        groupBy: {
          args: Prisma.UserGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserGroupByOutputType>[]
        }
        count: {
          args: Prisma.UserCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserCountAggregateOutputType> | number
        }
      }
    }
    Account: {
      payload: Prisma.$AccountPayload<ExtArgs>
      fields: Prisma.AccountFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AccountFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>
        }
        findFirst: {
          args: Prisma.AccountFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>
        }
        findMany: {
          args: Prisma.AccountFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>[]
        }
        create: {
          args: Prisma.AccountCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>
        }
        createMany: {
          args: Prisma.AccountCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.AccountDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>
        }
        update: {
          args: Prisma.AccountUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>
        }
        deleteMany: {
          args: Prisma.AccountDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AccountUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.AccountUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>
        }
        aggregate: {
          args: Prisma.AccountAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAccount>
        }
        groupBy: {
          args: Prisma.AccountGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AccountGroupByOutputType>[]
        }
        count: {
          args: Prisma.AccountCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AccountCountAggregateOutputType> | number
        }
      }
    }
    Session: {
      payload: Prisma.$SessionPayload<ExtArgs>
      fields: Prisma.SessionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SessionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>
        }
        findFirst: {
          args: Prisma.SessionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>
        }
        findMany: {
          args: Prisma.SessionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>[]
        }
        create: {
          args: Prisma.SessionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>
        }
        createMany: {
          args: Prisma.SessionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.SessionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>
        }
        update: {
          args: Prisma.SessionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>
        }
        deleteMany: {
          args: Prisma.SessionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SessionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.SessionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>
        }
        aggregate: {
          args: Prisma.SessionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSession>
        }
        groupBy: {
          args: Prisma.SessionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SessionGroupByOutputType>[]
        }
        count: {
          args: Prisma.SessionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SessionCountAggregateOutputType> | number
        }
      }
    }
    Tag: {
      payload: Prisma.$TagPayload<ExtArgs>
      fields: Prisma.TagFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TagFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TagPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TagFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TagPayload>
        }
        findFirst: {
          args: Prisma.TagFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TagPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TagFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TagPayload>
        }
        findMany: {
          args: Prisma.TagFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TagPayload>[]
        }
        create: {
          args: Prisma.TagCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TagPayload>
        }
        createMany: {
          args: Prisma.TagCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.TagDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TagPayload>
        }
        update: {
          args: Prisma.TagUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TagPayload>
        }
        deleteMany: {
          args: Prisma.TagDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TagUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.TagUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TagPayload>
        }
        aggregate: {
          args: Prisma.TagAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTag>
        }
        groupBy: {
          args: Prisma.TagGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TagGroupByOutputType>[]
        }
        count: {
          args: Prisma.TagCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TagCountAggregateOutputType> | number
        }
      }
    }
    LinkTag: {
      payload: Prisma.$LinkTagPayload<ExtArgs>
      fields: Prisma.LinkTagFieldRefs
      operations: {
        findUnique: {
          args: Prisma.LinkTagFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LinkTagPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.LinkTagFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LinkTagPayload>
        }
        findFirst: {
          args: Prisma.LinkTagFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LinkTagPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.LinkTagFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LinkTagPayload>
        }
        findMany: {
          args: Prisma.LinkTagFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LinkTagPayload>[]
        }
        create: {
          args: Prisma.LinkTagCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LinkTagPayload>
        }
        createMany: {
          args: Prisma.LinkTagCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.LinkTagDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LinkTagPayload>
        }
        update: {
          args: Prisma.LinkTagUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LinkTagPayload>
        }
        deleteMany: {
          args: Prisma.LinkTagDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.LinkTagUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.LinkTagUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LinkTagPayload>
        }
        aggregate: {
          args: Prisma.LinkTagAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateLinkTag>
        }
        groupBy: {
          args: Prisma.LinkTagGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LinkTagGroupByOutputType>[]
        }
        count: {
          args: Prisma.LinkTagCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LinkTagCountAggregateOutputType> | number
        }
      }
    }
    Token: {
      payload: Prisma.$TokenPayload<ExtArgs>
      fields: Prisma.TokenFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TokenFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TokenPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TokenFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TokenPayload>
        }
        findFirst: {
          args: Prisma.TokenFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TokenPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TokenFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TokenPayload>
        }
        findMany: {
          args: Prisma.TokenFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TokenPayload>[]
        }
        create: {
          args: Prisma.TokenCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TokenPayload>
        }
        createMany: {
          args: Prisma.TokenCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.TokenDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TokenPayload>
        }
        update: {
          args: Prisma.TokenUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TokenPayload>
        }
        deleteMany: {
          args: Prisma.TokenDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TokenUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.TokenUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TokenPayload>
        }
        aggregate: {
          args: Prisma.TokenAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateToken>
        }
        groupBy: {
          args: Prisma.TokenGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TokenGroupByOutputType>[]
        }
        count: {
          args: Prisma.TokenCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TokenCountAggregateOutputType> | number
        }
      }
    }
    RestrictedToken: {
      payload: Prisma.$RestrictedTokenPayload<ExtArgs>
      fields: Prisma.RestrictedTokenFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RestrictedTokenFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RestrictedTokenPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RestrictedTokenFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RestrictedTokenPayload>
        }
        findFirst: {
          args: Prisma.RestrictedTokenFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RestrictedTokenPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RestrictedTokenFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RestrictedTokenPayload>
        }
        findMany: {
          args: Prisma.RestrictedTokenFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RestrictedTokenPayload>[]
        }
        create: {
          args: Prisma.RestrictedTokenCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RestrictedTokenPayload>
        }
        createMany: {
          args: Prisma.RestrictedTokenCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.RestrictedTokenDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RestrictedTokenPayload>
        }
        update: {
          args: Prisma.RestrictedTokenUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RestrictedTokenPayload>
        }
        deleteMany: {
          args: Prisma.RestrictedTokenDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RestrictedTokenUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.RestrictedTokenUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RestrictedTokenPayload>
        }
        aggregate: {
          args: Prisma.RestrictedTokenAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRestrictedToken>
        }
        groupBy: {
          args: Prisma.RestrictedTokenGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RestrictedTokenGroupByOutputType>[]
        }
        count: {
          args: Prisma.RestrictedTokenCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RestrictedTokenCountAggregateOutputType> | number
        }
      }
    }
    VerificationToken: {
      payload: Prisma.$VerificationTokenPayload<ExtArgs>
      fields: Prisma.VerificationTokenFieldRefs
      operations: {
        findUnique: {
          args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
        }
        findFirst: {
          args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
        }
        findMany: {
          args: Prisma.VerificationTokenFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
        }
        create: {
          args: Prisma.VerificationTokenCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
        }
        createMany: {
          args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.VerificationTokenDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
        }
        update: {
          args: Prisma.VerificationTokenUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
        }
        deleteMany: {
          args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.VerificationTokenUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
        }
        aggregate: {
          args: Prisma.VerificationTokenAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateVerificationToken>
        }
        groupBy: {
          args: Prisma.VerificationTokenGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VerificationTokenGroupByOutputType>[]
        }
        count: {
          args: Prisma.VerificationTokenCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VerificationTokenCountAggregateOutputType> | number
        }
      }
    }
    EmailVerificationToken: {
      payload: Prisma.$EmailVerificationTokenPayload<ExtArgs>
      fields: Prisma.EmailVerificationTokenFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EmailVerificationTokenFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EmailVerificationTokenFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>
        }
        findFirst: {
          args: Prisma.EmailVerificationTokenFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EmailVerificationTokenFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>
        }
        findMany: {
          args: Prisma.EmailVerificationTokenFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>[]
        }
        create: {
          args: Prisma.EmailVerificationTokenCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>
        }
        createMany: {
          args: Prisma.EmailVerificationTokenCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.EmailVerificationTokenDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>
        }
        update: {
          args: Prisma.EmailVerificationTokenUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>
        }
        deleteMany: {
          args: Prisma.EmailVerificationTokenDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EmailVerificationTokenUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.EmailVerificationTokenUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>
        }
        aggregate: {
          args: Prisma.EmailVerificationTokenAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEmailVerificationToken>
        }
        groupBy: {
          args: Prisma.EmailVerificationTokenGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EmailVerificationTokenGroupByOutputType>[]
        }
        count: {
          args: Prisma.EmailVerificationTokenCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EmailVerificationTokenCountAggregateOutputType> | number
        }
      }
    }
    PasswordResetToken: {
      payload: Prisma.$PasswordResetTokenPayload<ExtArgs>
      fields: Prisma.PasswordResetTokenFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PasswordResetTokenFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
        }
        findFirst: {
          args: Prisma.PasswordResetTokenFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PasswordResetTokenFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
        }
        findMany: {
          args: Prisma.PasswordResetTokenFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
        }
        create: {
          args: Prisma.PasswordResetTokenCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
        }
        createMany: {
          args: Prisma.PasswordResetTokenCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.PasswordResetTokenDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
        }
        update: {
          args: Prisma.PasswordResetTokenUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
        }
        deleteMany: {
          args: Prisma.PasswordResetTokenDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PasswordResetTokenUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.PasswordResetTokenUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
        }
        aggregate: {
          args: Prisma.PasswordResetTokenAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePasswordResetToken>
        }
        groupBy: {
          args: Prisma.PasswordResetTokenGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PasswordResetTokenGroupByOutputType>[]
        }
        count: {
          args: Prisma.PasswordResetTokenCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PasswordResetTokenCountAggregateOutputType> | number
        }
      }
    }
    UtmTemplate: {
      payload: Prisma.$UtmTemplatePayload<ExtArgs>
      fields: Prisma.UtmTemplateFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UtmTemplateFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UtmTemplatePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UtmTemplateFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UtmTemplatePayload>
        }
        findFirst: {
          args: Prisma.UtmTemplateFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UtmTemplatePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UtmTemplateFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UtmTemplatePayload>
        }
        findMany: {
          args: Prisma.UtmTemplateFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UtmTemplatePayload>[]
        }
        create: {
          args: Prisma.UtmTemplateCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UtmTemplatePayload>
        }
        createMany: {
          args: Prisma.UtmTemplateCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.UtmTemplateDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UtmTemplatePayload>
        }
        update: {
          args: Prisma.UtmTemplateUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UtmTemplatePayload>
        }
        deleteMany: {
          args: Prisma.UtmTemplateDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UtmTemplateUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.UtmTemplateUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UtmTemplatePayload>
        }
        aggregate: {
          args: Prisma.UtmTemplateAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUtmTemplate>
        }
        groupBy: {
          args: Prisma.UtmTemplateGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UtmTemplateGroupByOutputType>[]
        }
        count: {
          args: Prisma.UtmTemplateCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UtmTemplateCountAggregateOutputType> | number
        }
      }
    }
    Webhook: {
      payload: Prisma.$WebhookPayload<ExtArgs>
      fields: Prisma.WebhookFieldRefs
      operations: {
        findUnique: {
          args: Prisma.WebhookFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.WebhookFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookPayload>
        }
        findFirst: {
          args: Prisma.WebhookFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.WebhookFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookPayload>
        }
        findMany: {
          args: Prisma.WebhookFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookPayload>[]
        }
        create: {
          args: Prisma.WebhookCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookPayload>
        }
        createMany: {
          args: Prisma.WebhookCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.WebhookDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookPayload>
        }
        update: {
          args: Prisma.WebhookUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookPayload>
        }
        deleteMany: {
          args: Prisma.WebhookDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.WebhookUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.WebhookUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookPayload>
        }
        aggregate: {
          args: Prisma.WebhookAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateWebhook>
        }
        groupBy: {
          args: Prisma.WebhookGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WebhookGroupByOutputType>[]
        }
        count: {
          args: Prisma.WebhookCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WebhookCountAggregateOutputType> | number
        }
      }
    }
    LinkWebhook: {
      payload: Prisma.$LinkWebhookPayload<ExtArgs>
      fields: Prisma.LinkWebhookFieldRefs
      operations: {
        findUnique: {
          args: Prisma.LinkWebhookFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LinkWebhookPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.LinkWebhookFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LinkWebhookPayload>
        }
        findFirst: {
          args: Prisma.LinkWebhookFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LinkWebhookPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.LinkWebhookFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LinkWebhookPayload>
        }
        findMany: {
          args: Prisma.LinkWebhookFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LinkWebhookPayload>[]
        }
        create: {
          args: Prisma.LinkWebhookCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LinkWebhookPayload>
        }
        createMany: {
          args: Prisma.LinkWebhookCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.LinkWebhookDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LinkWebhookPayload>
        }
        update: {
          args: Prisma.LinkWebhookUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LinkWebhookPayload>
        }
        deleteMany: {
          args: Prisma.LinkWebhookDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.LinkWebhookUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.LinkWebhookUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LinkWebhookPayload>
        }
        aggregate: {
          args: Prisma.LinkWebhookAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateLinkWebhook>
        }
        groupBy: {
          args: Prisma.LinkWebhookGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LinkWebhookGroupByOutputType>[]
        }
        count: {
          args: Prisma.LinkWebhookCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LinkWebhookCountAggregateOutputType> | number
        }
      }
    }
    Workflow: {
      payload: Prisma.$WorkflowPayload<ExtArgs>
      fields: Prisma.WorkflowFieldRefs
      operations: {
        findUnique: {
          args: Prisma.WorkflowFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkflowPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.WorkflowFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkflowPayload>
        }
        findFirst: {
          args: Prisma.WorkflowFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkflowPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.WorkflowFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkflowPayload>
        }
        findMany: {
          args: Prisma.WorkflowFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkflowPayload>[]
        }
        create: {
          args: Prisma.WorkflowCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkflowPayload>
        }
        createMany: {
          args: Prisma.WorkflowCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.WorkflowDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkflowPayload>
        }
        update: {
          args: Prisma.WorkflowUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkflowPayload>
        }
        deleteMany: {
          args: Prisma.WorkflowDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.WorkflowUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.WorkflowUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkflowPayload>
        }
        aggregate: {
          args: Prisma.WorkflowAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateWorkflow>
        }
        groupBy: {
          args: Prisma.WorkflowGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WorkflowGroupByOutputType>[]
        }
        count: {
          args: Prisma.WorkflowCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WorkflowCountAggregateOutputType> | number
        }
      }
    }
    Project: {
      payload: Prisma.$ProjectPayload<ExtArgs>
      fields: Prisma.ProjectFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ProjectFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ProjectFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload>
        }
        findFirst: {
          args: Prisma.ProjectFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ProjectFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload>
        }
        findMany: {
          args: Prisma.ProjectFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload>[]
        }
        create: {
          args: Prisma.ProjectCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload>
        }
        createMany: {
          args: Prisma.ProjectCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.ProjectDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload>
        }
        update: {
          args: Prisma.ProjectUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload>
        }
        deleteMany: {
          args: Prisma.ProjectDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ProjectUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.ProjectUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload>
        }
        aggregate: {
          args: Prisma.ProjectAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProject>
        }
        groupBy: {
          args: Prisma.ProjectGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProjectGroupByOutputType>[]
        }
        count: {
          args: Prisma.ProjectCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProjectCountAggregateOutputType> | number
        }
      }
    }
    ProjectInvite: {
      payload: Prisma.$ProjectInvitePayload<ExtArgs>
      fields: Prisma.ProjectInviteFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ProjectInviteFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectInvitePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ProjectInviteFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectInvitePayload>
        }
        findFirst: {
          args: Prisma.ProjectInviteFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectInvitePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ProjectInviteFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectInvitePayload>
        }
        findMany: {
          args: Prisma.ProjectInviteFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectInvitePayload>[]
        }
        create: {
          args: Prisma.ProjectInviteCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectInvitePayload>
        }
        createMany: {
          args: Prisma.ProjectInviteCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.ProjectInviteDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectInvitePayload>
        }
        update: {
          args: Prisma.ProjectInviteUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectInvitePayload>
        }
        deleteMany: {
          args: Prisma.ProjectInviteDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ProjectInviteUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.ProjectInviteUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectInvitePayload>
        }
        aggregate: {
          args: Prisma.ProjectInviteAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProjectInvite>
        }
        groupBy: {
          args: Prisma.ProjectInviteGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProjectInviteGroupByOutputType>[]
        }
        count: {
          args: Prisma.ProjectInviteCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProjectInviteCountAggregateOutputType> | number
        }
      }
    }
    ProjectUsers: {
      payload: Prisma.$ProjectUsersPayload<ExtArgs>
      fields: Prisma.ProjectUsersFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ProjectUsersFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectUsersPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ProjectUsersFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectUsersPayload>
        }
        findFirst: {
          args: Prisma.ProjectUsersFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectUsersPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ProjectUsersFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectUsersPayload>
        }
        findMany: {
          args: Prisma.ProjectUsersFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectUsersPayload>[]
        }
        create: {
          args: Prisma.ProjectUsersCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectUsersPayload>
        }
        createMany: {
          args: Prisma.ProjectUsersCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.ProjectUsersDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectUsersPayload>
        }
        update: {
          args: Prisma.ProjectUsersUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectUsersPayload>
        }
        deleteMany: {
          args: Prisma.ProjectUsersDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ProjectUsersUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.ProjectUsersUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectUsersPayload>
        }
        aggregate: {
          args: Prisma.ProjectUsersAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProjectUsers>
        }
        groupBy: {
          args: Prisma.ProjectUsersGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProjectUsersGroupByOutputType>[]
        }
        count: {
          args: Prisma.ProjectUsersCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProjectUsersCountAggregateOutputType> | number
        }
      }
    }
    SentEmail: {
      payload: Prisma.$SentEmailPayload<ExtArgs>
      fields: Prisma.SentEmailFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SentEmailFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SentEmailPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SentEmailFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SentEmailPayload>
        }
        findFirst: {
          args: Prisma.SentEmailFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SentEmailPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SentEmailFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SentEmailPayload>
        }
        findMany: {
          args: Prisma.SentEmailFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SentEmailPayload>[]
        }
        create: {
          args: Prisma.SentEmailCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SentEmailPayload>
        }
        createMany: {
          args: Prisma.SentEmailCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.SentEmailDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SentEmailPayload>
        }
        update: {
          args: Prisma.SentEmailUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SentEmailPayload>
        }
        deleteMany: {
          args: Prisma.SentEmailDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SentEmailUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.SentEmailUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SentEmailPayload>
        }
        aggregate: {
          args: Prisma.SentEmailAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSentEmail>
        }
        groupBy: {
          args: Prisma.SentEmailGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SentEmailGroupByOutputType>[]
        }
        count: {
          args: Prisma.SentEmailCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SentEmailCountAggregateOutputType> | number
        }
      }
    }
  }
} & {
  other: {
    payload: any
    operations: {
      $executeRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $executeRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
      $queryRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $queryRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
    }
  }
}

/**
 * Enums
 */

export const TransactionIsolationLevel = runtime.makeStrictEnum({
  ReadUncommitted: 'ReadUncommitted',
  ReadCommitted: 'ReadCommitted',
  RepeatableRead: 'RepeatableRead',
  Serializable: 'Serializable'
} as const)

export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


export const BountyScalarFieldEnum = {
  id: 'id',
  programId: 'programId',
  workflowId: 'workflowId',
  name: 'name',
  description: 'description',
  type: 'type',
  startsAt: 'startsAt',
  endsAt: 'endsAt',
  submissionsOpenAt: 'submissionsOpenAt',
  rewardAmount: 'rewardAmount',
  rewardDescription: 'rewardDescription',
  performanceScope: 'performanceScope',
  submissionRequirements: 'submissionRequirements',
  archivedAt: 'archivedAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type BountyScalarFieldEnum = (typeof BountyScalarFieldEnum)[keyof typeof BountyScalarFieldEnum]


export const BountyGroupScalarFieldEnum = {
  id: 'id',
  bountyId: 'bountyId',
  groupId: 'groupId'
} as const

export type BountyGroupScalarFieldEnum = (typeof BountyGroupScalarFieldEnum)[keyof typeof BountyGroupScalarFieldEnum]


export const BountySubmissionScalarFieldEnum = {
  id: 'id',
  programId: 'programId',
  partnerId: 'partnerId',
  bountyId: 'bountyId',
  performanceCount: 'performanceCount',
  commissionId: 'commissionId',
  userId: 'userId',
  description: 'description',
  status: 'status',
  rejectionReason: 'rejectionReason',
  rejectionNote: 'rejectionNote',
  files: 'files',
  urls: 'urls',
  completedAt: 'completedAt',
  reviewedAt: 'reviewedAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type BountySubmissionScalarFieldEnum = (typeof BountySubmissionScalarFieldEnum)[keyof typeof BountySubmissionScalarFieldEnum]


export const CampaignScalarFieldEnum = {
  id: 'id',
  programId: 'programId',
  workflowId: 'workflowId',
  userId: 'userId',
  qstashMessageId: 'qstashMessageId',
  type: 'type',
  status: 'status',
  name: 'name',
  subject: 'subject',
  preview: 'preview',
  from: 'from',
  bodyJson: 'bodyJson',
  scheduledAt: 'scheduledAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CampaignScalarFieldEnum = (typeof CampaignScalarFieldEnum)[keyof typeof CampaignScalarFieldEnum]


export const CampaignGroupScalarFieldEnum = {
  id: 'id',
  campaignId: 'campaignId',
  groupId: 'groupId'
} as const

export type CampaignGroupScalarFieldEnum = (typeof CampaignGroupScalarFieldEnum)[keyof typeof CampaignGroupScalarFieldEnum]


export const PartnerCommentScalarFieldEnum = {
  id: 'id',
  programId: 'programId',
  partnerId: 'partnerId',
  userId: 'userId',
  text: 'text',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type PartnerCommentScalarFieldEnum = (typeof PartnerCommentScalarFieldEnum)[keyof typeof PartnerCommentScalarFieldEnum]


export const CommissionScalarFieldEnum = {
  id: 'id',
  programId: 'programId',
  partnerId: 'partnerId',
  rewardId: 'rewardId',
  linkId: 'linkId',
  payoutId: 'payoutId',
  invoiceId: 'invoiceId',
  customerId: 'customerId',
  eventId: 'eventId',
  description: 'description',
  type: 'type',
  amount: 'amount',
  quantity: 'quantity',
  earnings: 'earnings',
  currency: 'currency',
  status: 'status',
  userId: 'userId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CommissionScalarFieldEnum = (typeof CommissionScalarFieldEnum)[keyof typeof CommissionScalarFieldEnum]


export const CustomerScalarFieldEnum = {
  id: 'id',
  name: 'name',
  email: 'email',
  avatar: 'avatar',
  externalId: 'externalId',
  stripeCustomerId: 'stripeCustomerId',
  linkId: 'linkId',
  clickId: 'clickId',
  clickedAt: 'clickedAt',
  country: 'country',
  sales: 'sales',
  saleAmount: 'saleAmount',
  projectId: 'projectId',
  projectConnectId: 'projectConnectId',
  programId: 'programId',
  partnerId: 'partnerId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


export const DashboardScalarFieldEnum = {
  id: 'id',
  linkId: 'linkId',
  folderId: 'folderId',
  projectId: 'projectId',
  userId: 'userId',
  doIndex: 'doIndex',
  password: 'password',
  showConversions: 'showConversions',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type DashboardScalarFieldEnum = (typeof DashboardScalarFieldEnum)[keyof typeof DashboardScalarFieldEnum]


export const DiscountScalarFieldEnum = {
  id: 'id',
  programId: 'programId',
  amount: 'amount',
  type: 'type',
  maxDuration: 'maxDuration',
  description: 'description',
  couponId: 'couponId',
  couponTestId: 'couponTestId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type DiscountScalarFieldEnum = (typeof DiscountScalarFieldEnum)[keyof typeof DiscountScalarFieldEnum]


export const DiscountCodeScalarFieldEnum = {
  id: 'id',
  code: 'code',
  programId: 'programId',
  discountId: 'discountId',
  partnerId: 'partnerId',
  linkId: 'linkId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type DiscountCodeScalarFieldEnum = (typeof DiscountCodeScalarFieldEnum)[keyof typeof DiscountCodeScalarFieldEnum]


export const DomainScalarFieldEnum = {
  id: 'id',
  slug: 'slug',
  verified: 'verified',
  placeholder: 'placeholder',
  expiredUrl: 'expiredUrl',
  notFoundUrl: 'notFoundUrl',
  primary: 'primary',
  archived: 'archived',
  lastChecked: 'lastChecked',
  logo: 'logo',
  appleAppSiteAssociation: 'appleAppSiteAssociation',
  assetLinks: 'assetLinks',
  deepviewData: 'deepviewData',
  linkRetentionDays: 'linkRetentionDays',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  projectId: 'projectId'
} as const

export type DomainScalarFieldEnum = (typeof DomainScalarFieldEnum)[keyof typeof DomainScalarFieldEnum]


export const RegisteredDomainScalarFieldEnum = {
  id: 'id',
  slug: 'slug',
  projectId: 'projectId',
  domainId: 'domainId',
  autoRenewalDisabledAt: 'autoRenewalDisabledAt',
  renewalFee: 'renewalFee',
  expiresAt: 'expiresAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type RegisteredDomainScalarFieldEnum = (typeof RegisteredDomainScalarFieldEnum)[keyof typeof RegisteredDomainScalarFieldEnum]


export const DefaultDomainsScalarFieldEnum = {
  id: 'id',
  dublink: 'dublink',
  dubsh: 'dubsh',
  chatgpt: 'chatgpt',
  sptifi: 'sptifi',
  gitnew: 'gitnew',
  callink: 'callink',
  amznid: 'amznid',
  ggllink: 'ggllink',
  figpage: 'figpage',
  loooooooong: 'loooooooong',
  projectId: 'projectId'
} as const

export type DefaultDomainsScalarFieldEnum = (typeof DefaultDomainsScalarFieldEnum)[keyof typeof DefaultDomainsScalarFieldEnum]


export const EmailDomainScalarFieldEnum = {
  id: 'id',
  workspaceId: 'workspaceId',
  programId: 'programId',
  slug: 'slug',
  status: 'status',
  resendDomainId: 'resendDomainId',
  lastChecked: 'lastChecked',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type EmailDomainScalarFieldEnum = (typeof EmailDomainScalarFieldEnum)[keyof typeof EmailDomainScalarFieldEnum]


export const FolderScalarFieldEnum = {
  id: 'id',
  name: 'name',
  description: 'description',
  projectId: 'projectId',
  type: 'type',
  accessLevel: 'accessLevel',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type FolderScalarFieldEnum = (typeof FolderScalarFieldEnum)[keyof typeof FolderScalarFieldEnum]


export const FolderUserScalarFieldEnum = {
  id: 'id',
  folderId: 'folderId',
  userId: 'userId',
  role: 'role',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type FolderUserScalarFieldEnum = (typeof FolderUserScalarFieldEnum)[keyof typeof FolderUserScalarFieldEnum]


export const FolderAccessRequestScalarFieldEnum = {
  id: 'id',
  folderId: 'folderId',
  userId: 'userId',
  createdAt: 'createdAt'
} as const

export type FolderAccessRequestScalarFieldEnum = (typeof FolderAccessRequestScalarFieldEnum)[keyof typeof FolderAccessRequestScalarFieldEnum]


export const FraudRuleScalarFieldEnum = {
  id: 'id',
  programId: 'programId',
  type: 'type',
  config: 'config',
  disabledAt: 'disabledAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type FraudRuleScalarFieldEnum = (typeof FraudRuleScalarFieldEnum)[keyof typeof FraudRuleScalarFieldEnum]


export const FraudEventGroupScalarFieldEnum = {
  id: 'id',
  programId: 'programId',
  partnerId: 'partnerId',
  type: 'type',
  lastEventAt: 'lastEventAt',
  eventCount: 'eventCount',
  userId: 'userId',
  resolutionReason: 'resolutionReason',
  resolvedAt: 'resolvedAt',
  status: 'status',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type FraudEventGroupScalarFieldEnum = (typeof FraudEventGroupScalarFieldEnum)[keyof typeof FraudEventGroupScalarFieldEnum]


export const FraudEventScalarFieldEnum = {
  id: 'id',
  fraudEventGroupId: 'fraudEventGroupId',
  programId: 'programId',
  partnerId: 'partnerId',
  linkId: 'linkId',
  customerId: 'customerId',
  eventId: 'eventId',
  hash: 'hash',
  metadata: 'metadata',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type FraudEventScalarFieldEnum = (typeof FraudEventScalarFieldEnum)[keyof typeof FraudEventScalarFieldEnum]


export const PartnerGroupScalarFieldEnum = {
  id: 'id',
  programId: 'programId',
  name: 'name',
  slug: 'slug',
  color: 'color',
  clickRewardId: 'clickRewardId',
  leadRewardId: 'leadRewardId',
  saleRewardId: 'saleRewardId',
  discountId: 'discountId',
  linkStructure: 'linkStructure',
  additionalLinks: 'additionalLinks',
  maxPartnerLinks: 'maxPartnerLinks',
  applicationFormData: 'applicationFormData',
  applicationFormPublishedAt: 'applicationFormPublishedAt',
  landerData: 'landerData',
  landerPublishedAt: 'landerPublishedAt',
  logo: 'logo',
  wordmark: 'wordmark',
  brandColor: 'brandColor',
  holdingPeriodDays: 'holdingPeriodDays',
  autoApprovePartnersEnabledAt: 'autoApprovePartnersEnabledAt',
  utmTemplateId: 'utmTemplateId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type PartnerGroupScalarFieldEnum = (typeof PartnerGroupScalarFieldEnum)[keyof typeof PartnerGroupScalarFieldEnum]


export const PartnerGroupDefaultLinkScalarFieldEnum = {
  id: 'id',
  programId: 'programId',
  groupId: 'groupId',
  domain: 'domain',
  url: 'url',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type PartnerGroupDefaultLinkScalarFieldEnum = (typeof PartnerGroupDefaultLinkScalarFieldEnum)[keyof typeof PartnerGroupDefaultLinkScalarFieldEnum]


export const IntegrationScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  projectId: 'projectId',
  name: 'name',
  slug: 'slug',
  description: 'description',
  readme: 'readme',
  developer: 'developer',
  website: 'website',
  logo: 'logo',
  screenshots: 'screenshots',
  verified: 'verified',
  installUrl: 'installUrl',
  guideUrl: 'guideUrl',
  category: 'category',
  comingSoon: 'comingSoon',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type IntegrationScalarFieldEnum = (typeof IntegrationScalarFieldEnum)[keyof typeof IntegrationScalarFieldEnum]


export const InstalledIntegrationScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  integrationId: 'integrationId',
  projectId: 'projectId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  credentials: 'credentials',
  settings: 'settings'
} as const

export type InstalledIntegrationScalarFieldEnum = (typeof InstalledIntegrationScalarFieldEnum)[keyof typeof InstalledIntegrationScalarFieldEnum]


export const InvoiceScalarFieldEnum = {
  id: 'id',
  programId: 'programId',
  workspaceId: 'workspaceId',
  number: 'number',
  status: 'status',
  type: 'type',
  payoutMode: 'payoutMode',
  paymentMethod: 'paymentMethod',
  amount: 'amount',
  fee: 'fee',
  total: 'total',
  externalAmount: 'externalAmount',
  receiptUrl: 'receiptUrl',
  failedReason: 'failedReason',
  registeredDomains: 'registeredDomains',
  stripeChargeMetadata: 'stripeChargeMetadata',
  failedAttempts: 'failedAttempts',
  createdAt: 'createdAt',
  paidAt: 'paidAt'
} as const

export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


export const Jackson_indexScalarFieldEnum = {
  id: 'id',
  key: 'key',
  storeKey: 'storeKey'
} as const

export type Jackson_indexScalarFieldEnum = (typeof Jackson_indexScalarFieldEnum)[keyof typeof Jackson_indexScalarFieldEnum]


export const Jackson_storeScalarFieldEnum = {
  key: 'key',
  value: 'value',
  iv: 'iv',
  tag: 'tag',
  namespace: 'namespace',
  createdAt: 'createdAt',
  modifiedAt: 'modifiedAt'
} as const

export type Jackson_storeScalarFieldEnum = (typeof Jackson_storeScalarFieldEnum)[keyof typeof Jackson_storeScalarFieldEnum]


export const Jackson_ttlScalarFieldEnum = {
  key: 'key',
  expiresAt: 'expiresAt'
} as const

export type Jackson_ttlScalarFieldEnum = (typeof Jackson_ttlScalarFieldEnum)[keyof typeof Jackson_ttlScalarFieldEnum]


export const LinkScalarFieldEnum = {
  id: 'id',
  domain: 'domain',
  key: 'key',
  url: 'url',
  shortLink: 'shortLink',
  archived: 'archived',
  expiresAt: 'expiresAt',
  expiredUrl: 'expiredUrl',
  disabledAt: 'disabledAt',
  password: 'password',
  trackConversion: 'trackConversion',
  proxy: 'proxy',
  title: 'title',
  description: 'description',
  image: 'image',
  video: 'video',
  utm_source: 'utm_source',
  utm_medium: 'utm_medium',
  utm_campaign: 'utm_campaign',
  utm_term: 'utm_term',
  utm_content: 'utm_content',
  rewrite: 'rewrite',
  linkRetentionCleanupDisabledAt: 'linkRetentionCleanupDisabledAt',
  doIndex: 'doIndex',
  ios: 'ios',
  android: 'android',
  geo: 'geo',
  testVariants: 'testVariants',
  testStartedAt: 'testStartedAt',
  testCompletedAt: 'testCompletedAt',
  userId: 'userId',
  projectId: 'projectId',
  folderId: 'folderId',
  externalId: 'externalId',
  tenantId: 'tenantId',
  publicStats: 'publicStats',
  clicks: 'clicks',
  leads: 'leads',
  conversions: 'conversions',
  sales: 'sales',
  saleAmount: 'saleAmount',
  lastClicked: 'lastClicked',
  lastLeadAt: 'lastLeadAt',
  lastConversionAt: 'lastConversionAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  comments: 'comments',
  programId: 'programId',
  partnerId: 'partnerId',
  partnerGroupDefaultLinkId: 'partnerGroupDefaultLinkId'
} as const

export type LinkScalarFieldEnum = (typeof LinkScalarFieldEnum)[keyof typeof LinkScalarFieldEnum]


export const MessageScalarFieldEnum = {
  id: 'id',
  programId: 'programId',
  partnerId: 'partnerId',
  senderUserId: 'senderUserId',
  senderPartnerId: 'senderPartnerId',
  type: 'type',
  subject: 'subject',
  text: 'text',
  readInApp: 'readInApp',
  readInEmail: 'readInEmail',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


export const YearInReviewScalarFieldEnum = {
  id: 'id',
  year: 'year',
  totalLinks: 'totalLinks',
  totalClicks: 'totalClicks',
  topLinks: 'topLinks',
  topCountries: 'topCountries',
  workspaceId: 'workspaceId',
  createdAt: 'createdAt',
  sentAt: 'sentAt'
} as const

export type YearInReviewScalarFieldEnum = (typeof YearInReviewScalarFieldEnum)[keyof typeof YearInReviewScalarFieldEnum]


export const PartnerRewindScalarFieldEnum = {
  id: 'id',
  year: 'year',
  totalClicks: 'totalClicks',
  totalLeads: 'totalLeads',
  totalRevenue: 'totalRevenue',
  totalEarnings: 'totalEarnings',
  partnerId: 'partnerId',
  createdAt: 'createdAt',
  sentAt: 'sentAt'
} as const

export type PartnerRewindScalarFieldEnum = (typeof PartnerRewindScalarFieldEnum)[keyof typeof PartnerRewindScalarFieldEnum]


export const ProgramCategoryScalarFieldEnum = {
  programId: 'programId',
  category: 'category'
} as const

export type ProgramCategoryScalarFieldEnum = (typeof ProgramCategoryScalarFieldEnum)[keyof typeof ProgramCategoryScalarFieldEnum]


export const ProgramSimilarityScalarFieldEnum = {
  id: 'id',
  programId: 'programId',
  similarProgramId: 'similarProgramId',
  similarityScore: 'similarityScore',
  categorySimilarityScore: 'categorySimilarityScore',
  partnerSimilarityScore: 'partnerSimilarityScore',
  performanceSimilarityScore: 'performanceSimilarityScore'
} as const

export type ProgramSimilarityScalarFieldEnum = (typeof ProgramSimilarityScalarFieldEnum)[keyof typeof ProgramSimilarityScalarFieldEnum]


export const DiscoveredPartnerScalarFieldEnum = {
  id: 'id',
  programId: 'programId',
  partnerId: 'partnerId',
  starredAt: 'starredAt',
  ignoredAt: 'ignoredAt',
  invitedAt: 'invitedAt',
  messagedAt: 'messagedAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type DiscoveredPartnerScalarFieldEnum = (typeof DiscoveredPartnerScalarFieldEnum)[keyof typeof DiscoveredPartnerScalarFieldEnum]


export const NotificationEmailScalarFieldEnum = {
  id: 'id',
  emailId: 'emailId',
  type: 'type',
  messageId: 'messageId',
  bountyId: 'bountyId',
  campaignId: 'campaignId',
  programId: 'programId',
  partnerId: 'partnerId',
  recipientUserId: 'recipientUserId',
  deliveredAt: 'deliveredAt',
  openedAt: 'openedAt',
  bouncedAt: 'bouncedAt',
  createdAt: 'createdAt'
} as const

export type NotificationEmailScalarFieldEnum = (typeof NotificationEmailScalarFieldEnum)[keyof typeof NotificationEmailScalarFieldEnum]


export const NotificationPreferenceScalarFieldEnum = {
  id: 'id',
  projectUserId: 'projectUserId',
  linkUsageSummary: 'linkUsageSummary',
  domainConfigurationUpdates: 'domainConfigurationUpdates',
  newPartnerSale: 'newPartnerSale',
  newPartnerApplication: 'newPartnerApplication',
  newBountySubmitted: 'newBountySubmitted',
  newMessageFromPartner: 'newMessageFromPartner',
  fraudEventsSummary: 'fraudEventsSummary'
} as const

export type NotificationPreferenceScalarFieldEnum = (typeof NotificationPreferenceScalarFieldEnum)[keyof typeof NotificationPreferenceScalarFieldEnum]


export const PartnerNotificationPreferencesScalarFieldEnum = {
  id: 'id',
  partnerUserId: 'partnerUserId',
  commissionCreated: 'commissionCreated',
  applicationApproved: 'applicationApproved',
  newMessageFromProgram: 'newMessageFromProgram',
  marketingCampaign: 'marketingCampaign'
} as const

export type PartnerNotificationPreferencesScalarFieldEnum = (typeof PartnerNotificationPreferencesScalarFieldEnum)[keyof typeof PartnerNotificationPreferencesScalarFieldEnum]


export const OAuthAppScalarFieldEnum = {
  id: 'id',
  integrationId: 'integrationId',
  clientId: 'clientId',
  hashedClientSecret: 'hashedClientSecret',
  partialClientSecret: 'partialClientSecret',
  redirectUris: 'redirectUris',
  pkce: 'pkce'
} as const

export type OAuthAppScalarFieldEnum = (typeof OAuthAppScalarFieldEnum)[keyof typeof OAuthAppScalarFieldEnum]


export const OAuthCodeScalarFieldEnum = {
  id: 'id',
  clientId: 'clientId',
  userId: 'userId',
  projectId: 'projectId',
  code: 'code',
  scopes: 'scopes',
  redirectUri: 'redirectUri',
  codeChallenge: 'codeChallenge',
  codeChallengeMethod: 'codeChallengeMethod',
  expiresAt: 'expiresAt',
  createdAt: 'createdAt'
} as const

export type OAuthCodeScalarFieldEnum = (typeof OAuthCodeScalarFieldEnum)[keyof typeof OAuthCodeScalarFieldEnum]


export const OAuthRefreshTokenScalarFieldEnum = {
  id: 'id',
  installationId: 'installationId',
  accessTokenId: 'accessTokenId',
  hashedRefreshToken: 'hashedRefreshToken',
  expiresAt: 'expiresAt',
  createdAt: 'createdAt'
} as const

export type OAuthRefreshTokenScalarFieldEnum = (typeof OAuthRefreshTokenScalarFieldEnum)[keyof typeof OAuthRefreshTokenScalarFieldEnum]


export const PartnerScalarFieldEnum = {
  id: 'id',
  name: 'name',
  companyName: 'companyName',
  profileType: 'profileType',
  email: 'email',
  image: 'image',
  description: 'description',
  country: 'country',
  paypalEmail: 'paypalEmail',
  stripeConnectId: 'stripeConnectId',
  payoutsEnabledAt: 'payoutsEnabledAt',
  payoutMethodHash: 'payoutMethodHash',
  connectPayoutsLastRemindedAt: 'connectPayoutsLastRemindedAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  discoverableAt: 'discoverableAt',
  trustedAt: 'trustedAt',
  website: 'website',
  websiteTxtRecord: 'websiteTxtRecord',
  websiteVerifiedAt: 'websiteVerifiedAt',
  youtube: 'youtube',
  youtubeChannelId: 'youtubeChannelId',
  youtubeVerifiedAt: 'youtubeVerifiedAt',
  youtubeSubscriberCount: 'youtubeSubscriberCount',
  youtubeVideoCount: 'youtubeVideoCount',
  youtubeViewCount: 'youtubeViewCount',
  twitter: 'twitter',
  twitterVerifiedAt: 'twitterVerifiedAt',
  linkedin: 'linkedin',
  linkedinVerifiedAt: 'linkedinVerifiedAt',
  instagram: 'instagram',
  instagramVerifiedAt: 'instagramVerifiedAt',
  tiktok: 'tiktok',
  tiktokVerifiedAt: 'tiktokVerifiedAt',
  invoiceSettings: 'invoiceSettings',
  changeHistoryLog: 'changeHistoryLog',
  monthlyTraffic: 'monthlyTraffic'
} as const

export type PartnerScalarFieldEnum = (typeof PartnerScalarFieldEnum)[keyof typeof PartnerScalarFieldEnum]


export const PartnerInviteScalarFieldEnum = {
  email: 'email',
  expires: 'expires',
  partnerId: 'partnerId',
  role: 'role',
  createdAt: 'createdAt'
} as const

export type PartnerInviteScalarFieldEnum = (typeof PartnerInviteScalarFieldEnum)[keyof typeof PartnerInviteScalarFieldEnum]


export const PartnerUserScalarFieldEnum = {
  id: 'id',
  role: 'role',
  userId: 'userId',
  partnerId: 'partnerId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type PartnerUserScalarFieldEnum = (typeof PartnerUserScalarFieldEnum)[keyof typeof PartnerUserScalarFieldEnum]


export const PartnerIndustryInterestScalarFieldEnum = {
  partnerId: 'partnerId',
  industryInterest: 'industryInterest'
} as const

export type PartnerIndustryInterestScalarFieldEnum = (typeof PartnerIndustryInterestScalarFieldEnum)[keyof typeof PartnerIndustryInterestScalarFieldEnum]


export const PartnerPreferredEarningStructureScalarFieldEnum = {
  partnerId: 'partnerId',
  preferredEarningStructure: 'preferredEarningStructure'
} as const

export type PartnerPreferredEarningStructureScalarFieldEnum = (typeof PartnerPreferredEarningStructureScalarFieldEnum)[keyof typeof PartnerPreferredEarningStructureScalarFieldEnum]


export const PartnerSalesChannelScalarFieldEnum = {
  partnerId: 'partnerId',
  salesChannel: 'salesChannel'
} as const

export type PartnerSalesChannelScalarFieldEnum = (typeof PartnerSalesChannelScalarFieldEnum)[keyof typeof PartnerSalesChannelScalarFieldEnum]


export const PayoutScalarFieldEnum = {
  id: 'id',
  programId: 'programId',
  partnerId: 'partnerId',
  invoiceId: 'invoiceId',
  amount: 'amount',
  currency: 'currency',
  status: 'status',
  mode: 'mode',
  description: 'description',
  periodStart: 'periodStart',
  periodEnd: 'periodEnd',
  paypalTransferId: 'paypalTransferId',
  stripeTransferId: 'stripeTransferId',
  stripePayoutId: 'stripePayoutId',
  stripePayoutTraceId: 'stripePayoutTraceId',
  failureReason: 'failureReason',
  webhookEventId: 'webhookEventId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  userId: 'userId',
  initiatedAt: 'initiatedAt',
  paidAt: 'paidAt'
} as const

export type PayoutScalarFieldEnum = (typeof PayoutScalarFieldEnum)[keyof typeof PayoutScalarFieldEnum]


export const ProgramScalarFieldEnum = {
  id: 'id',
  workspaceId: 'workspaceId',
  defaultFolderId: 'defaultFolderId',
  defaultGroupId: 'defaultGroupId',
  name: 'name',
  slug: 'slug',
  domain: 'domain',
  url: 'url',
  logo: 'logo',
  description: 'description',
  primaryRewardEvent: 'primaryRewardEvent',
  minPayoutAmount: 'minPayoutAmount',
  payoutMode: 'payoutMode',
  inviteEmailData: 'inviteEmailData',
  embedData: 'embedData',
  resources: 'resources',
  termsUrl: 'termsUrl',
  helpUrl: 'helpUrl',
  supportEmail: 'supportEmail',
  messagingEnabledAt: 'messagingEnabledAt',
  partnerNetworkEnabledAt: 'partnerNetworkEnabledAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  startedAt: 'startedAt',
  addedToMarketplaceAt: 'addedToMarketplaceAt',
  featuredOnMarketplaceAt: 'featuredOnMarketplaceAt',
  marketplaceHeaderImage: 'marketplaceHeaderImage'
} as const

export type ProgramScalarFieldEnum = (typeof ProgramScalarFieldEnum)[keyof typeof ProgramScalarFieldEnum]


export const ProgramEnrollmentScalarFieldEnum = {
  id: 'id',
  partnerId: 'partnerId',
  programId: 'programId',
  tenantId: 'tenantId',
  groupId: 'groupId',
  applicationId: 'applicationId',
  clickRewardId: 'clickRewardId',
  leadRewardId: 'leadRewardId',
  saleRewardId: 'saleRewardId',
  discountId: 'discountId',
  status: 'status',
  totalClicks: 'totalClicks',
  totalLeads: 'totalLeads',
  totalConversions: 'totalConversions',
  totalSales: 'totalSales',
  totalSaleAmount: 'totalSaleAmount',
  totalCommissions: 'totalCommissions',
  netRevenue: 'netRevenue',
  earningsPerClick: 'earningsPerClick',
  averageLifetimeValue: 'averageLifetimeValue',
  clickToLeadRate: 'clickToLeadRate',
  clickToConversionRate: 'clickToConversionRate',
  leadToConversionRate: 'leadToConversionRate',
  returnOnAdSpend: 'returnOnAdSpend',
  lastConversionAt: 'lastConversionAt',
  daysSinceLastConversion: 'daysSinceLastConversion',
  consistencyScore: 'consistencyScore',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  customerDataSharingEnabledAt: 'customerDataSharingEnabledAt',
  bannedAt: 'bannedAt',
  bannedReason: 'bannedReason'
} as const

export type ProgramEnrollmentScalarFieldEnum = (typeof ProgramEnrollmentScalarFieldEnum)[keyof typeof ProgramEnrollmentScalarFieldEnum]


export const ProgramApplicationScalarFieldEnum = {
  id: 'id',
  programId: 'programId',
  groupId: 'groupId',
  name: 'name',
  email: 'email',
  country: 'country',
  website: 'website',
  youtube: 'youtube',
  twitter: 'twitter',
  linkedin: 'linkedin',
  instagram: 'instagram',
  tiktok: 'tiktok',
  formData: 'formData',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ProgramApplicationScalarFieldEnum = (typeof ProgramApplicationScalarFieldEnum)[keyof typeof ProgramApplicationScalarFieldEnum]


export const RewardScalarFieldEnum = {
  id: 'id',
  programId: 'programId',
  description: 'description',
  tooltipDescription: 'tooltipDescription',
  event: 'event',
  type: 'type',
  amountInCents: 'amountInCents',
  amountInPercentage: 'amountInPercentage',
  maxDuration: 'maxDuration',
  modifiers: 'modifiers',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type RewardScalarFieldEnum = (typeof RewardScalarFieldEnum)[keyof typeof RewardScalarFieldEnum]


export const UserScalarFieldEnum = {
  id: 'id',
  name: 'name',
  email: 'email',
  emailVerified: 'emailVerified',
  image: 'image',
  isMachine: 'isMachine',
  passwordHash: 'passwordHash',
  invalidLoginAttempts: 'invalidLoginAttempts',
  lockedAt: 'lockedAt',
  createdAt: 'createdAt',
  subscribed: 'subscribed',
  source: 'source',
  defaultWorkspace: 'defaultWorkspace',
  defaultPartnerId: 'defaultPartnerId'
} as const

export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


export const AccountScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  type: 'type',
  provider: 'provider',
  providerAccountId: 'providerAccountId',
  refresh_token: 'refresh_token',
  refresh_token_expires_in: 'refresh_token_expires_in',
  access_token: 'access_token',
  expires_at: 'expires_at',
  token_type: 'token_type',
  scope: 'scope',
  id_token: 'id_token',
  session_state: 'session_state'
} as const

export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


export const SessionScalarFieldEnum = {
  id: 'id',
  sessionToken: 'sessionToken',
  userId: 'userId',
  expires: 'expires'
} as const

export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


export const TagScalarFieldEnum = {
  id: 'id',
  name: 'name',
  color: 'color',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  projectId: 'projectId'
} as const

export type TagScalarFieldEnum = (typeof TagScalarFieldEnum)[keyof typeof TagScalarFieldEnum]


export const LinkTagScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  linkId: 'linkId',
  tagId: 'tagId'
} as const

export type LinkTagScalarFieldEnum = (typeof LinkTagScalarFieldEnum)[keyof typeof LinkTagScalarFieldEnum]


export const TokenScalarFieldEnum = {
  id: 'id',
  name: 'name',
  hashedKey: 'hashedKey',
  partialKey: 'partialKey',
  expires: 'expires',
  lastUsed: 'lastUsed',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  userId: 'userId'
} as const

export type TokenScalarFieldEnum = (typeof TokenScalarFieldEnum)[keyof typeof TokenScalarFieldEnum]


export const RestrictedTokenScalarFieldEnum = {
  id: 'id',
  name: 'name',
  hashedKey: 'hashedKey',
  partialKey: 'partialKey',
  scopes: 'scopes',
  expires: 'expires',
  lastUsed: 'lastUsed',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  userId: 'userId',
  projectId: 'projectId',
  installationId: 'installationId'
} as const

export type RestrictedTokenScalarFieldEnum = (typeof RestrictedTokenScalarFieldEnum)[keyof typeof RestrictedTokenScalarFieldEnum]


export const VerificationTokenScalarFieldEnum = {
  identifier: 'identifier',
  token: 'token',
  expires: 'expires'
} as const

export type VerificationTokenScalarFieldEnum = (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum]


export const EmailVerificationTokenScalarFieldEnum = {
  identifier: 'identifier',
  token: 'token',
  expires: 'expires'
} as const

export type EmailVerificationTokenScalarFieldEnum = (typeof EmailVerificationTokenScalarFieldEnum)[keyof typeof EmailVerificationTokenScalarFieldEnum]


export const PasswordResetTokenScalarFieldEnum = {
  identifier: 'identifier',
  token: 'token',
  expires: 'expires'
} as const

export type PasswordResetTokenScalarFieldEnum = (typeof PasswordResetTokenScalarFieldEnum)[keyof typeof PasswordResetTokenScalarFieldEnum]


export const UtmTemplateScalarFieldEnum = {
  id: 'id',
  name: 'name',
  utm_source: 'utm_source',
  utm_medium: 'utm_medium',
  utm_campaign: 'utm_campaign',
  utm_term: 'utm_term',
  utm_content: 'utm_content',
  ref: 'ref',
  userId: 'userId',
  projectId: 'projectId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type UtmTemplateScalarFieldEnum = (typeof UtmTemplateScalarFieldEnum)[keyof typeof UtmTemplateScalarFieldEnum]


export const WebhookScalarFieldEnum = {
  id: 'id',
  projectId: 'projectId',
  installationId: 'installationId',
  receiver: 'receiver',
  name: 'name',
  url: 'url',
  secret: 'secret',
  triggers: 'triggers',
  consecutiveFailures: 'consecutiveFailures',
  lastFailedAt: 'lastFailedAt',
  disabledAt: 'disabledAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type WebhookScalarFieldEnum = (typeof WebhookScalarFieldEnum)[keyof typeof WebhookScalarFieldEnum]


export const LinkWebhookScalarFieldEnum = {
  id: 'id',
  linkId: 'linkId',
  webhookId: 'webhookId'
} as const

export type LinkWebhookScalarFieldEnum = (typeof LinkWebhookScalarFieldEnum)[keyof typeof LinkWebhookScalarFieldEnum]


export const WorkflowScalarFieldEnum = {
  id: 'id',
  programId: 'programId',
  name: 'name',
  trigger: 'trigger',
  triggerConditions: 'triggerConditions',
  actions: 'actions',
  disabledAt: 'disabledAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type WorkflowScalarFieldEnum = (typeof WorkflowScalarFieldEnum)[keyof typeof WorkflowScalarFieldEnum]


export const ProjectScalarFieldEnum = {
  id: 'id',
  name: 'name',
  slug: 'slug',
  logo: 'logo',
  inviteCode: 'inviteCode',
  defaultProgramId: 'defaultProgramId',
  plan: 'plan',
  planTier: 'planTier',
  stripeId: 'stripeId',
  billingCycleStart: 'billingCycleStart',
  paymentFailedAt: 'paymentFailedAt',
  invoicePrefix: 'invoicePrefix',
  stripeConnectId: 'stripeConnectId',
  shopifyStoreId: 'shopifyStoreId',
  totalLinks: 'totalLinks',
  totalClicks: 'totalClicks',
  usage: 'usage',
  usageLimit: 'usageLimit',
  linksUsage: 'linksUsage',
  linksLimit: 'linksLimit',
  payoutsUsage: 'payoutsUsage',
  payoutsLimit: 'payoutsLimit',
  payoutFee: 'payoutFee',
  domainsLimit: 'domainsLimit',
  tagsLimit: 'tagsLimit',
  foldersUsage: 'foldersUsage',
  foldersLimit: 'foldersLimit',
  groupsLimit: 'groupsLimit',
  usersLimit: 'usersLimit',
  aiUsage: 'aiUsage',
  aiLimit: 'aiLimit',
  networkInvitesLimit: 'networkInvitesLimit',
  referralLinkId: 'referralLinkId',
  referredSignups: 'referredSignups',
  store: 'store',
  allowedHostnames: 'allowedHostnames',
  publishableKey: 'publishableKey',
  conversionEnabled: 'conversionEnabled',
  webhookEnabled: 'webhookEnabled',
  dotLinkClaimed: 'dotLinkClaimed',
  fastDirectDebitPayouts: 'fastDirectDebitPayouts',
  ssoEmailDomain: 'ssoEmailDomain',
  ssoEnforcedAt: 'ssoEnforcedAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  usageLastChecked: 'usageLastChecked'
} as const

export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


export const ProjectInviteScalarFieldEnum = {
  email: 'email',
  expires: 'expires',
  projectId: 'projectId',
  role: 'role',
  createdAt: 'createdAt'
} as const

export type ProjectInviteScalarFieldEnum = (typeof ProjectInviteScalarFieldEnum)[keyof typeof ProjectInviteScalarFieldEnum]


export const ProjectUsersScalarFieldEnum = {
  id: 'id',
  role: 'role',
  userId: 'userId',
  projectId: 'projectId',
  workspacePreferences: 'workspacePreferences',
  defaultFolderId: 'defaultFolderId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ProjectUsersScalarFieldEnum = (typeof ProjectUsersScalarFieldEnum)[keyof typeof ProjectUsersScalarFieldEnum]


export const SentEmailScalarFieldEnum = {
  id: 'id',
  type: 'type',
  createdAt: 'createdAt',
  projectId: 'projectId'
} as const

export type SentEmailScalarFieldEnum = (typeof SentEmailScalarFieldEnum)[keyof typeof SentEmailScalarFieldEnum]


export const SortOrder = {
  asc: 'asc',
  desc: 'desc'
} as const

export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


export const NullableJsonNullValueInput = {
  DbNull: DbNull,
  JsonNull: JsonNull
} as const

export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


export const JsonNullValueInput = {
  JsonNull: JsonNull
} as const

export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


export const JsonNullValueFilter = {
  DbNull: DbNull,
  JsonNull: JsonNull,
  AnyNull: AnyNull
} as const

export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


export const QueryMode = {
  default: 'default',
  insensitive: 'insensitive'
} as const

export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


export const NullsOrder = {
  first: 'first',
  last: 'last'
} as const

export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


export const BountyOrderByRelevanceFieldEnum = {
  id: 'id',
  programId: 'programId',
  workflowId: 'workflowId',
  name: 'name',
  description: 'description',
  rewardDescription: 'rewardDescription'
} as const

export type BountyOrderByRelevanceFieldEnum = (typeof BountyOrderByRelevanceFieldEnum)[keyof typeof BountyOrderByRelevanceFieldEnum]


export const BountyGroupOrderByRelevanceFieldEnum = {
  id: 'id',
  bountyId: 'bountyId',
  groupId: 'groupId'
} as const

export type BountyGroupOrderByRelevanceFieldEnum = (typeof BountyGroupOrderByRelevanceFieldEnum)[keyof typeof BountyGroupOrderByRelevanceFieldEnum]


export const BountySubmissionOrderByRelevanceFieldEnum = {
  id: 'id',
  programId: 'programId',
  partnerId: 'partnerId',
  bountyId: 'bountyId',
  commissionId: 'commissionId',
  userId: 'userId',
  description: 'description',
  rejectionNote: 'rejectionNote'
} as const

export type BountySubmissionOrderByRelevanceFieldEnum = (typeof BountySubmissionOrderByRelevanceFieldEnum)[keyof typeof BountySubmissionOrderByRelevanceFieldEnum]


export const CampaignOrderByRelevanceFieldEnum = {
  id: 'id',
  programId: 'programId',
  workflowId: 'workflowId',
  userId: 'userId',
  qstashMessageId: 'qstashMessageId',
  name: 'name',
  subject: 'subject',
  preview: 'preview',
  from: 'from'
} as const

export type CampaignOrderByRelevanceFieldEnum = (typeof CampaignOrderByRelevanceFieldEnum)[keyof typeof CampaignOrderByRelevanceFieldEnum]


export const CampaignGroupOrderByRelevanceFieldEnum = {
  id: 'id',
  campaignId: 'campaignId',
  groupId: 'groupId'
} as const

export type CampaignGroupOrderByRelevanceFieldEnum = (typeof CampaignGroupOrderByRelevanceFieldEnum)[keyof typeof CampaignGroupOrderByRelevanceFieldEnum]


export const PartnerCommentOrderByRelevanceFieldEnum = {
  id: 'id',
  programId: 'programId',
  partnerId: 'partnerId',
  userId: 'userId',
  text: 'text'
} as const

export type PartnerCommentOrderByRelevanceFieldEnum = (typeof PartnerCommentOrderByRelevanceFieldEnum)[keyof typeof PartnerCommentOrderByRelevanceFieldEnum]


export const CommissionOrderByRelevanceFieldEnum = {
  id: 'id',
  programId: 'programId',
  partnerId: 'partnerId',
  rewardId: 'rewardId',
  linkId: 'linkId',
  payoutId: 'payoutId',
  invoiceId: 'invoiceId',
  customerId: 'customerId',
  eventId: 'eventId',
  description: 'description',
  currency: 'currency',
  userId: 'userId'
} as const

export type CommissionOrderByRelevanceFieldEnum = (typeof CommissionOrderByRelevanceFieldEnum)[keyof typeof CommissionOrderByRelevanceFieldEnum]


export const CustomerOrderByRelevanceFieldEnum = {
  id: 'id',
  name: 'name',
  email: 'email',
  avatar: 'avatar',
  externalId: 'externalId',
  stripeCustomerId: 'stripeCustomerId',
  linkId: 'linkId',
  clickId: 'clickId',
  country: 'country',
  projectId: 'projectId',
  projectConnectId: 'projectConnectId',
  programId: 'programId',
  partnerId: 'partnerId'
} as const

export type CustomerOrderByRelevanceFieldEnum = (typeof CustomerOrderByRelevanceFieldEnum)[keyof typeof CustomerOrderByRelevanceFieldEnum]


export const DashboardOrderByRelevanceFieldEnum = {
  id: 'id',
  linkId: 'linkId',
  folderId: 'folderId',
  projectId: 'projectId',
  userId: 'userId',
  password: 'password'
} as const

export type DashboardOrderByRelevanceFieldEnum = (typeof DashboardOrderByRelevanceFieldEnum)[keyof typeof DashboardOrderByRelevanceFieldEnum]


export const DiscountOrderByRelevanceFieldEnum = {
  id: 'id',
  programId: 'programId',
  description: 'description',
  couponId: 'couponId',
  couponTestId: 'couponTestId'
} as const

export type DiscountOrderByRelevanceFieldEnum = (typeof DiscountOrderByRelevanceFieldEnum)[keyof typeof DiscountOrderByRelevanceFieldEnum]


export const DiscountCodeOrderByRelevanceFieldEnum = {
  id: 'id',
  code: 'code',
  programId: 'programId',
  discountId: 'discountId',
  partnerId: 'partnerId',
  linkId: 'linkId'
} as const

export type DiscountCodeOrderByRelevanceFieldEnum = (typeof DiscountCodeOrderByRelevanceFieldEnum)[keyof typeof DiscountCodeOrderByRelevanceFieldEnum]


export const DomainOrderByRelevanceFieldEnum = {
  id: 'id',
  slug: 'slug',
  placeholder: 'placeholder',
  expiredUrl: 'expiredUrl',
  notFoundUrl: 'notFoundUrl',
  logo: 'logo',
  projectId: 'projectId'
} as const

export type DomainOrderByRelevanceFieldEnum = (typeof DomainOrderByRelevanceFieldEnum)[keyof typeof DomainOrderByRelevanceFieldEnum]


export const RegisteredDomainOrderByRelevanceFieldEnum = {
  id: 'id',
  slug: 'slug',
  projectId: 'projectId',
  domainId: 'domainId'
} as const

export type RegisteredDomainOrderByRelevanceFieldEnum = (typeof RegisteredDomainOrderByRelevanceFieldEnum)[keyof typeof RegisteredDomainOrderByRelevanceFieldEnum]


export const DefaultDomainsOrderByRelevanceFieldEnum = {
  id: 'id',
  projectId: 'projectId'
} as const

export type DefaultDomainsOrderByRelevanceFieldEnum = (typeof DefaultDomainsOrderByRelevanceFieldEnum)[keyof typeof DefaultDomainsOrderByRelevanceFieldEnum]


export const EmailDomainOrderByRelevanceFieldEnum = {
  id: 'id',
  workspaceId: 'workspaceId',
  programId: 'programId',
  slug: 'slug',
  resendDomainId: 'resendDomainId'
} as const

export type EmailDomainOrderByRelevanceFieldEnum = (typeof EmailDomainOrderByRelevanceFieldEnum)[keyof typeof EmailDomainOrderByRelevanceFieldEnum]


export const FolderOrderByRelevanceFieldEnum = {
  id: 'id',
  name: 'name',
  description: 'description',
  projectId: 'projectId'
} as const

export type FolderOrderByRelevanceFieldEnum = (typeof FolderOrderByRelevanceFieldEnum)[keyof typeof FolderOrderByRelevanceFieldEnum]


export const FolderUserOrderByRelevanceFieldEnum = {
  id: 'id',
  folderId: 'folderId',
  userId: 'userId'
} as const

export type FolderUserOrderByRelevanceFieldEnum = (typeof FolderUserOrderByRelevanceFieldEnum)[keyof typeof FolderUserOrderByRelevanceFieldEnum]


export const FolderAccessRequestOrderByRelevanceFieldEnum = {
  id: 'id',
  folderId: 'folderId',
  userId: 'userId'
} as const

export type FolderAccessRequestOrderByRelevanceFieldEnum = (typeof FolderAccessRequestOrderByRelevanceFieldEnum)[keyof typeof FolderAccessRequestOrderByRelevanceFieldEnum]


export const FraudRuleOrderByRelevanceFieldEnum = {
  id: 'id',
  programId: 'programId'
} as const

export type FraudRuleOrderByRelevanceFieldEnum = (typeof FraudRuleOrderByRelevanceFieldEnum)[keyof typeof FraudRuleOrderByRelevanceFieldEnum]


export const FraudEventGroupOrderByRelevanceFieldEnum = {
  id: 'id',
  programId: 'programId',
  partnerId: 'partnerId',
  userId: 'userId',
  resolutionReason: 'resolutionReason'
} as const

export type FraudEventGroupOrderByRelevanceFieldEnum = (typeof FraudEventGroupOrderByRelevanceFieldEnum)[keyof typeof FraudEventGroupOrderByRelevanceFieldEnum]


export const FraudEventOrderByRelevanceFieldEnum = {
  id: 'id',
  fraudEventGroupId: 'fraudEventGroupId',
  programId: 'programId',
  partnerId: 'partnerId',
  linkId: 'linkId',
  customerId: 'customerId',
  eventId: 'eventId',
  hash: 'hash'
} as const

export type FraudEventOrderByRelevanceFieldEnum = (typeof FraudEventOrderByRelevanceFieldEnum)[keyof typeof FraudEventOrderByRelevanceFieldEnum]


export const PartnerGroupOrderByRelevanceFieldEnum = {
  id: 'id',
  programId: 'programId',
  name: 'name',
  slug: 'slug',
  color: 'color',
  clickRewardId: 'clickRewardId',
  leadRewardId: 'leadRewardId',
  saleRewardId: 'saleRewardId',
  discountId: 'discountId',
  logo: 'logo',
  wordmark: 'wordmark',
  brandColor: 'brandColor',
  utmTemplateId: 'utmTemplateId'
} as const

export type PartnerGroupOrderByRelevanceFieldEnum = (typeof PartnerGroupOrderByRelevanceFieldEnum)[keyof typeof PartnerGroupOrderByRelevanceFieldEnum]


export const PartnerGroupDefaultLinkOrderByRelevanceFieldEnum = {
  id: 'id',
  programId: 'programId',
  groupId: 'groupId',
  domain: 'domain',
  url: 'url'
} as const

export type PartnerGroupDefaultLinkOrderByRelevanceFieldEnum = (typeof PartnerGroupDefaultLinkOrderByRelevanceFieldEnum)[keyof typeof PartnerGroupDefaultLinkOrderByRelevanceFieldEnum]


export const IntegrationOrderByRelevanceFieldEnum = {
  id: 'id',
  userId: 'userId',
  projectId: 'projectId',
  name: 'name',
  slug: 'slug',
  description: 'description',
  readme: 'readme',
  developer: 'developer',
  website: 'website',
  logo: 'logo',
  installUrl: 'installUrl',
  guideUrl: 'guideUrl',
  category: 'category'
} as const

export type IntegrationOrderByRelevanceFieldEnum = (typeof IntegrationOrderByRelevanceFieldEnum)[keyof typeof IntegrationOrderByRelevanceFieldEnum]


export const InstalledIntegrationOrderByRelevanceFieldEnum = {
  id: 'id',
  userId: 'userId',
  integrationId: 'integrationId',
  projectId: 'projectId'
} as const

export type InstalledIntegrationOrderByRelevanceFieldEnum = (typeof InstalledIntegrationOrderByRelevanceFieldEnum)[keyof typeof InstalledIntegrationOrderByRelevanceFieldEnum]


export const InvoiceOrderByRelevanceFieldEnum = {
  id: 'id',
  programId: 'programId',
  workspaceId: 'workspaceId',
  number: 'number',
  receiptUrl: 'receiptUrl',
  failedReason: 'failedReason'
} as const

export type InvoiceOrderByRelevanceFieldEnum = (typeof InvoiceOrderByRelevanceFieldEnum)[keyof typeof InvoiceOrderByRelevanceFieldEnum]


export const jackson_indexOrderByRelevanceFieldEnum = {
  key: 'key',
  storeKey: 'storeKey'
} as const

export type jackson_indexOrderByRelevanceFieldEnum = (typeof jackson_indexOrderByRelevanceFieldEnum)[keyof typeof jackson_indexOrderByRelevanceFieldEnum]


export const jackson_storeOrderByRelevanceFieldEnum = {
  key: 'key',
  value: 'value',
  iv: 'iv',
  tag: 'tag',
  namespace: 'namespace'
} as const

export type jackson_storeOrderByRelevanceFieldEnum = (typeof jackson_storeOrderByRelevanceFieldEnum)[keyof typeof jackson_storeOrderByRelevanceFieldEnum]


export const jackson_ttlOrderByRelevanceFieldEnum = {
  key: 'key'
} as const

export type jackson_ttlOrderByRelevanceFieldEnum = (typeof jackson_ttlOrderByRelevanceFieldEnum)[keyof typeof jackson_ttlOrderByRelevanceFieldEnum]


export const LinkOrderByRelevanceFieldEnum = {
  id: 'id',
  domain: 'domain',
  key: 'key',
  url: 'url',
  shortLink: 'shortLink',
  expiredUrl: 'expiredUrl',
  password: 'password',
  title: 'title',
  description: 'description',
  image: 'image',
  video: 'video',
  utm_source: 'utm_source',
  utm_medium: 'utm_medium',
  utm_campaign: 'utm_campaign',
  utm_term: 'utm_term',
  utm_content: 'utm_content',
  ios: 'ios',
  android: 'android',
  userId: 'userId',
  projectId: 'projectId',
  folderId: 'folderId',
  externalId: 'externalId',
  tenantId: 'tenantId',
  comments: 'comments',
  programId: 'programId',
  partnerId: 'partnerId',
  partnerGroupDefaultLinkId: 'partnerGroupDefaultLinkId'
} as const

export type LinkOrderByRelevanceFieldEnum = (typeof LinkOrderByRelevanceFieldEnum)[keyof typeof LinkOrderByRelevanceFieldEnum]


export const MessageOrderByRelevanceFieldEnum = {
  id: 'id',
  programId: 'programId',
  partnerId: 'partnerId',
  senderUserId: 'senderUserId',
  senderPartnerId: 'senderPartnerId',
  subject: 'subject',
  text: 'text'
} as const

export type MessageOrderByRelevanceFieldEnum = (typeof MessageOrderByRelevanceFieldEnum)[keyof typeof MessageOrderByRelevanceFieldEnum]


export const YearInReviewOrderByRelevanceFieldEnum = {
  id: 'id',
  workspaceId: 'workspaceId'
} as const

export type YearInReviewOrderByRelevanceFieldEnum = (typeof YearInReviewOrderByRelevanceFieldEnum)[keyof typeof YearInReviewOrderByRelevanceFieldEnum]


export const PartnerRewindOrderByRelevanceFieldEnum = {
  id: 'id',
  partnerId: 'partnerId'
} as const

export type PartnerRewindOrderByRelevanceFieldEnum = (typeof PartnerRewindOrderByRelevanceFieldEnum)[keyof typeof PartnerRewindOrderByRelevanceFieldEnum]


export const ProgramCategoryOrderByRelevanceFieldEnum = {
  programId: 'programId'
} as const

export type ProgramCategoryOrderByRelevanceFieldEnum = (typeof ProgramCategoryOrderByRelevanceFieldEnum)[keyof typeof ProgramCategoryOrderByRelevanceFieldEnum]


export const ProgramSimilarityOrderByRelevanceFieldEnum = {
  id: 'id',
  programId: 'programId',
  similarProgramId: 'similarProgramId'
} as const

export type ProgramSimilarityOrderByRelevanceFieldEnum = (typeof ProgramSimilarityOrderByRelevanceFieldEnum)[keyof typeof ProgramSimilarityOrderByRelevanceFieldEnum]


export const DiscoveredPartnerOrderByRelevanceFieldEnum = {
  id: 'id',
  programId: 'programId',
  partnerId: 'partnerId'
} as const

export type DiscoveredPartnerOrderByRelevanceFieldEnum = (typeof DiscoveredPartnerOrderByRelevanceFieldEnum)[keyof typeof DiscoveredPartnerOrderByRelevanceFieldEnum]


export const NotificationEmailOrderByRelevanceFieldEnum = {
  id: 'id',
  emailId: 'emailId',
  messageId: 'messageId',
  bountyId: 'bountyId',
  campaignId: 'campaignId',
  programId: 'programId',
  partnerId: 'partnerId',
  recipientUserId: 'recipientUserId'
} as const

export type NotificationEmailOrderByRelevanceFieldEnum = (typeof NotificationEmailOrderByRelevanceFieldEnum)[keyof typeof NotificationEmailOrderByRelevanceFieldEnum]


export const NotificationPreferenceOrderByRelevanceFieldEnum = {
  id: 'id',
  projectUserId: 'projectUserId'
} as const

export type NotificationPreferenceOrderByRelevanceFieldEnum = (typeof NotificationPreferenceOrderByRelevanceFieldEnum)[keyof typeof NotificationPreferenceOrderByRelevanceFieldEnum]


export const PartnerNotificationPreferencesOrderByRelevanceFieldEnum = {
  id: 'id',
  partnerUserId: 'partnerUserId'
} as const

export type PartnerNotificationPreferencesOrderByRelevanceFieldEnum = (typeof PartnerNotificationPreferencesOrderByRelevanceFieldEnum)[keyof typeof PartnerNotificationPreferencesOrderByRelevanceFieldEnum]


export const OAuthAppOrderByRelevanceFieldEnum = {
  id: 'id',
  integrationId: 'integrationId',
  clientId: 'clientId',
  hashedClientSecret: 'hashedClientSecret',
  partialClientSecret: 'partialClientSecret'
} as const

export type OAuthAppOrderByRelevanceFieldEnum = (typeof OAuthAppOrderByRelevanceFieldEnum)[keyof typeof OAuthAppOrderByRelevanceFieldEnum]


export const OAuthCodeOrderByRelevanceFieldEnum = {
  id: 'id',
  clientId: 'clientId',
  userId: 'userId',
  projectId: 'projectId',
  code: 'code',
  scopes: 'scopes',
  redirectUri: 'redirectUri',
  codeChallenge: 'codeChallenge',
  codeChallengeMethod: 'codeChallengeMethod'
} as const

export type OAuthCodeOrderByRelevanceFieldEnum = (typeof OAuthCodeOrderByRelevanceFieldEnum)[keyof typeof OAuthCodeOrderByRelevanceFieldEnum]


export const OAuthRefreshTokenOrderByRelevanceFieldEnum = {
  id: 'id',
  installationId: 'installationId',
  accessTokenId: 'accessTokenId',
  hashedRefreshToken: 'hashedRefreshToken'
} as const

export type OAuthRefreshTokenOrderByRelevanceFieldEnum = (typeof OAuthRefreshTokenOrderByRelevanceFieldEnum)[keyof typeof OAuthRefreshTokenOrderByRelevanceFieldEnum]


export const PartnerOrderByRelevanceFieldEnum = {
  id: 'id',
  name: 'name',
  companyName: 'companyName',
  email: 'email',
  image: 'image',
  description: 'description',
  country: 'country',
  paypalEmail: 'paypalEmail',
  stripeConnectId: 'stripeConnectId',
  payoutMethodHash: 'payoutMethodHash',
  website: 'website',
  websiteTxtRecord: 'websiteTxtRecord',
  youtube: 'youtube',
  youtubeChannelId: 'youtubeChannelId',
  twitter: 'twitter',
  linkedin: 'linkedin',
  instagram: 'instagram',
  tiktok: 'tiktok'
} as const

export type PartnerOrderByRelevanceFieldEnum = (typeof PartnerOrderByRelevanceFieldEnum)[keyof typeof PartnerOrderByRelevanceFieldEnum]


export const PartnerInviteOrderByRelevanceFieldEnum = {
  email: 'email',
  partnerId: 'partnerId'
} as const

export type PartnerInviteOrderByRelevanceFieldEnum = (typeof PartnerInviteOrderByRelevanceFieldEnum)[keyof typeof PartnerInviteOrderByRelevanceFieldEnum]


export const PartnerUserOrderByRelevanceFieldEnum = {
  id: 'id',
  userId: 'userId',
  partnerId: 'partnerId'
} as const

export type PartnerUserOrderByRelevanceFieldEnum = (typeof PartnerUserOrderByRelevanceFieldEnum)[keyof typeof PartnerUserOrderByRelevanceFieldEnum]


export const PartnerIndustryInterestOrderByRelevanceFieldEnum = {
  partnerId: 'partnerId'
} as const

export type PartnerIndustryInterestOrderByRelevanceFieldEnum = (typeof PartnerIndustryInterestOrderByRelevanceFieldEnum)[keyof typeof PartnerIndustryInterestOrderByRelevanceFieldEnum]


export const PartnerPreferredEarningStructureOrderByRelevanceFieldEnum = {
  partnerId: 'partnerId'
} as const

export type PartnerPreferredEarningStructureOrderByRelevanceFieldEnum = (typeof PartnerPreferredEarningStructureOrderByRelevanceFieldEnum)[keyof typeof PartnerPreferredEarningStructureOrderByRelevanceFieldEnum]


export const PartnerSalesChannelOrderByRelevanceFieldEnum = {
  partnerId: 'partnerId'
} as const

export type PartnerSalesChannelOrderByRelevanceFieldEnum = (typeof PartnerSalesChannelOrderByRelevanceFieldEnum)[keyof typeof PartnerSalesChannelOrderByRelevanceFieldEnum]


export const PayoutOrderByRelevanceFieldEnum = {
  id: 'id',
  programId: 'programId',
  partnerId: 'partnerId',
  invoiceId: 'invoiceId',
  currency: 'currency',
  description: 'description',
  paypalTransferId: 'paypalTransferId',
  stripeTransferId: 'stripeTransferId',
  stripePayoutId: 'stripePayoutId',
  stripePayoutTraceId: 'stripePayoutTraceId',
  failureReason: 'failureReason',
  webhookEventId: 'webhookEventId',
  userId: 'userId'
} as const

export type PayoutOrderByRelevanceFieldEnum = (typeof PayoutOrderByRelevanceFieldEnum)[keyof typeof PayoutOrderByRelevanceFieldEnum]


export const ProgramOrderByRelevanceFieldEnum = {
  id: 'id',
  workspaceId: 'workspaceId',
  defaultFolderId: 'defaultFolderId',
  defaultGroupId: 'defaultGroupId',
  name: 'name',
  slug: 'slug',
  domain: 'domain',
  url: 'url',
  logo: 'logo',
  description: 'description',
  termsUrl: 'termsUrl',
  helpUrl: 'helpUrl',
  supportEmail: 'supportEmail',
  marketplaceHeaderImage: 'marketplaceHeaderImage'
} as const

export type ProgramOrderByRelevanceFieldEnum = (typeof ProgramOrderByRelevanceFieldEnum)[keyof typeof ProgramOrderByRelevanceFieldEnum]


export const ProgramEnrollmentOrderByRelevanceFieldEnum = {
  id: 'id',
  partnerId: 'partnerId',
  programId: 'programId',
  tenantId: 'tenantId',
  groupId: 'groupId',
  applicationId: 'applicationId',
  clickRewardId: 'clickRewardId',
  leadRewardId: 'leadRewardId',
  saleRewardId: 'saleRewardId',
  discountId: 'discountId'
} as const

export type ProgramEnrollmentOrderByRelevanceFieldEnum = (typeof ProgramEnrollmentOrderByRelevanceFieldEnum)[keyof typeof ProgramEnrollmentOrderByRelevanceFieldEnum]


export const ProgramApplicationOrderByRelevanceFieldEnum = {
  id: 'id',
  programId: 'programId',
  groupId: 'groupId',
  name: 'name',
  email: 'email',
  country: 'country',
  website: 'website',
  youtube: 'youtube',
  twitter: 'twitter',
  linkedin: 'linkedin',
  instagram: 'instagram',
  tiktok: 'tiktok'
} as const

export type ProgramApplicationOrderByRelevanceFieldEnum = (typeof ProgramApplicationOrderByRelevanceFieldEnum)[keyof typeof ProgramApplicationOrderByRelevanceFieldEnum]


export const RewardOrderByRelevanceFieldEnum = {
  id: 'id',
  programId: 'programId',
  description: 'description',
  tooltipDescription: 'tooltipDescription'
} as const

export type RewardOrderByRelevanceFieldEnum = (typeof RewardOrderByRelevanceFieldEnum)[keyof typeof RewardOrderByRelevanceFieldEnum]


export const UserOrderByRelevanceFieldEnum = {
  id: 'id',
  name: 'name',
  email: 'email',
  image: 'image',
  passwordHash: 'passwordHash',
  source: 'source',
  defaultWorkspace: 'defaultWorkspace',
  defaultPartnerId: 'defaultPartnerId'
} as const

export type UserOrderByRelevanceFieldEnum = (typeof UserOrderByRelevanceFieldEnum)[keyof typeof UserOrderByRelevanceFieldEnum]


export const AccountOrderByRelevanceFieldEnum = {
  id: 'id',
  userId: 'userId',
  type: 'type',
  provider: 'provider',
  providerAccountId: 'providerAccountId',
  refresh_token: 'refresh_token',
  access_token: 'access_token',
  token_type: 'token_type',
  scope: 'scope',
  id_token: 'id_token',
  session_state: 'session_state'
} as const

export type AccountOrderByRelevanceFieldEnum = (typeof AccountOrderByRelevanceFieldEnum)[keyof typeof AccountOrderByRelevanceFieldEnum]


export const SessionOrderByRelevanceFieldEnum = {
  id: 'id',
  sessionToken: 'sessionToken',
  userId: 'userId'
} as const

export type SessionOrderByRelevanceFieldEnum = (typeof SessionOrderByRelevanceFieldEnum)[keyof typeof SessionOrderByRelevanceFieldEnum]


export const TagOrderByRelevanceFieldEnum = {
  id: 'id',
  name: 'name',
  color: 'color',
  projectId: 'projectId'
} as const

export type TagOrderByRelevanceFieldEnum = (typeof TagOrderByRelevanceFieldEnum)[keyof typeof TagOrderByRelevanceFieldEnum]


export const LinkTagOrderByRelevanceFieldEnum = {
  id: 'id',
  linkId: 'linkId',
  tagId: 'tagId'
} as const

export type LinkTagOrderByRelevanceFieldEnum = (typeof LinkTagOrderByRelevanceFieldEnum)[keyof typeof LinkTagOrderByRelevanceFieldEnum]


export const TokenOrderByRelevanceFieldEnum = {
  id: 'id',
  name: 'name',
  hashedKey: 'hashedKey',
  partialKey: 'partialKey',
  userId: 'userId'
} as const

export type TokenOrderByRelevanceFieldEnum = (typeof TokenOrderByRelevanceFieldEnum)[keyof typeof TokenOrderByRelevanceFieldEnum]


export const RestrictedTokenOrderByRelevanceFieldEnum = {
  id: 'id',
  name: 'name',
  hashedKey: 'hashedKey',
  partialKey: 'partialKey',
  scopes: 'scopes',
  userId: 'userId',
  projectId: 'projectId',
  installationId: 'installationId'
} as const

export type RestrictedTokenOrderByRelevanceFieldEnum = (typeof RestrictedTokenOrderByRelevanceFieldEnum)[keyof typeof RestrictedTokenOrderByRelevanceFieldEnum]


export const VerificationTokenOrderByRelevanceFieldEnum = {
  identifier: 'identifier',
  token: 'token'
} as const

export type VerificationTokenOrderByRelevanceFieldEnum = (typeof VerificationTokenOrderByRelevanceFieldEnum)[keyof typeof VerificationTokenOrderByRelevanceFieldEnum]


export const EmailVerificationTokenOrderByRelevanceFieldEnum = {
  identifier: 'identifier',
  token: 'token'
} as const

export type EmailVerificationTokenOrderByRelevanceFieldEnum = (typeof EmailVerificationTokenOrderByRelevanceFieldEnum)[keyof typeof EmailVerificationTokenOrderByRelevanceFieldEnum]


export const PasswordResetTokenOrderByRelevanceFieldEnum = {
  identifier: 'identifier',
  token: 'token'
} as const

export type PasswordResetTokenOrderByRelevanceFieldEnum = (typeof PasswordResetTokenOrderByRelevanceFieldEnum)[keyof typeof PasswordResetTokenOrderByRelevanceFieldEnum]


export const UtmTemplateOrderByRelevanceFieldEnum = {
  id: 'id',
  name: 'name',
  utm_source: 'utm_source',
  utm_medium: 'utm_medium',
  utm_campaign: 'utm_campaign',
  utm_term: 'utm_term',
  utm_content: 'utm_content',
  ref: 'ref',
  userId: 'userId',
  projectId: 'projectId'
} as const

export type UtmTemplateOrderByRelevanceFieldEnum = (typeof UtmTemplateOrderByRelevanceFieldEnum)[keyof typeof UtmTemplateOrderByRelevanceFieldEnum]


export const WebhookOrderByRelevanceFieldEnum = {
  id: 'id',
  projectId: 'projectId',
  installationId: 'installationId',
  name: 'name',
  url: 'url',
  secret: 'secret'
} as const

export type WebhookOrderByRelevanceFieldEnum = (typeof WebhookOrderByRelevanceFieldEnum)[keyof typeof WebhookOrderByRelevanceFieldEnum]


export const LinkWebhookOrderByRelevanceFieldEnum = {
  id: 'id',
  linkId: 'linkId',
  webhookId: 'webhookId'
} as const

export type LinkWebhookOrderByRelevanceFieldEnum = (typeof LinkWebhookOrderByRelevanceFieldEnum)[keyof typeof LinkWebhookOrderByRelevanceFieldEnum]


export const WorkflowOrderByRelevanceFieldEnum = {
  id: 'id',
  programId: 'programId',
  name: 'name'
} as const

export type WorkflowOrderByRelevanceFieldEnum = (typeof WorkflowOrderByRelevanceFieldEnum)[keyof typeof WorkflowOrderByRelevanceFieldEnum]


export const ProjectOrderByRelevanceFieldEnum = {
  id: 'id',
  name: 'name',
  slug: 'slug',
  logo: 'logo',
  inviteCode: 'inviteCode',
  defaultProgramId: 'defaultProgramId',
  plan: 'plan',
  stripeId: 'stripeId',
  invoicePrefix: 'invoicePrefix',
  stripeConnectId: 'stripeConnectId',
  shopifyStoreId: 'shopifyStoreId',
  referralLinkId: 'referralLinkId',
  publishableKey: 'publishableKey',
  ssoEmailDomain: 'ssoEmailDomain'
} as const

export type ProjectOrderByRelevanceFieldEnum = (typeof ProjectOrderByRelevanceFieldEnum)[keyof typeof ProjectOrderByRelevanceFieldEnum]


export const ProjectInviteOrderByRelevanceFieldEnum = {
  email: 'email',
  projectId: 'projectId'
} as const

export type ProjectInviteOrderByRelevanceFieldEnum = (typeof ProjectInviteOrderByRelevanceFieldEnum)[keyof typeof ProjectInviteOrderByRelevanceFieldEnum]


export const ProjectUsersOrderByRelevanceFieldEnum = {
  id: 'id',
  userId: 'userId',
  projectId: 'projectId',
  defaultFolderId: 'defaultFolderId'
} as const

export type ProjectUsersOrderByRelevanceFieldEnum = (typeof ProjectUsersOrderByRelevanceFieldEnum)[keyof typeof ProjectUsersOrderByRelevanceFieldEnum]


export const SentEmailOrderByRelevanceFieldEnum = {
  id: 'id',
  type: 'type',
  projectId: 'projectId'
} as const

export type SentEmailOrderByRelevanceFieldEnum = (typeof SentEmailOrderByRelevanceFieldEnum)[keyof typeof SentEmailOrderByRelevanceFieldEnum]



/**
 * Field references
 */


/**
 * Reference to a field of type 'String'
 */
export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


/**
 * Reference to a field of type 'BountyType'
 */
export type EnumBountyTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BountyType'>
    


/**
 * Reference to a field of type 'DateTime'
 */
export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


/**
 * Reference to a field of type 'Int'
 */
export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


/**
 * Reference to a field of type 'BountyPerformanceScope'
 */
export type EnumBountyPerformanceScopeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BountyPerformanceScope'>
    


/**
 * Reference to a field of type 'Json'
 */
export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


/**
 * Reference to a field of type 'QueryMode'
 */
export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


/**
 * Reference to a field of type 'BountySubmissionStatus'
 */
export type EnumBountySubmissionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BountySubmissionStatus'>
    


/**
 * Reference to a field of type 'BountySubmissionRejectionReason'
 */
export type EnumBountySubmissionRejectionReasonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BountySubmissionRejectionReason'>
    


/**
 * Reference to a field of type 'CampaignType'
 */
export type EnumCampaignTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CampaignType'>
    


/**
 * Reference to a field of type 'CampaignStatus'
 */
export type EnumCampaignStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CampaignStatus'>
    


/**
 * Reference to a field of type 'CommissionType'
 */
export type EnumCommissionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CommissionType'>
    


/**
 * Reference to a field of type 'CommissionStatus'
 */
export type EnumCommissionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CommissionStatus'>
    


/**
 * Reference to a field of type 'Boolean'
 */
export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


/**
 * Reference to a field of type 'RewardStructure'
 */
export type EnumRewardStructureFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RewardStructure'>
    


/**
 * Reference to a field of type 'EmailDomainStatus'
 */
export type EnumEmailDomainStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmailDomainStatus'>
    


/**
 * Reference to a field of type 'FolderType'
 */
export type EnumFolderTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FolderType'>
    


/**
 * Reference to a field of type 'FolderAccessLevel'
 */
export type EnumFolderAccessLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FolderAccessLevel'>
    


/**
 * Reference to a field of type 'FolderUserRole'
 */
export type EnumFolderUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FolderUserRole'>
    


/**
 * Reference to a field of type 'FraudRuleType'
 */
export type EnumFraudRuleTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FraudRuleType'>
    


/**
 * Reference to a field of type 'FraudEventStatus'
 */
export type EnumFraudEventStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FraudEventStatus'>
    


/**
 * Reference to a field of type 'PartnerLinkStructure'
 */
export type EnumPartnerLinkStructureFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PartnerLinkStructure'>
    


/**
 * Reference to a field of type 'InvoiceStatus'
 */
export type EnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceStatus'>
    


/**
 * Reference to a field of type 'InvoiceType'
 */
export type EnumInvoiceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceType'>
    


/**
 * Reference to a field of type 'ProgramPayoutMode'
 */
export type EnumProgramPayoutModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProgramPayoutMode'>
    


/**
 * Reference to a field of type 'PaymentMethod'
 */
export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


/**
 * Reference to a field of type 'BigInt'
 */
export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


/**
 * Reference to a field of type 'MessageType'
 */
export type EnumMessageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageType'>
    


/**
 * Reference to a field of type 'Category'
 */
export type EnumCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Category'>
    


/**
 * Reference to a field of type 'Float'
 */
export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


/**
 * Reference to a field of type 'NotificationEmailType'
 */
export type EnumNotificationEmailTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationEmailType'>
    


/**
 * Reference to a field of type 'PartnerProfileType'
 */
export type EnumPartnerProfileTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PartnerProfileType'>
    


/**
 * Reference to a field of type 'MonthlyTraffic'
 */
export type EnumMonthlyTrafficFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MonthlyTraffic'>
    


/**
 * Reference to a field of type 'PartnerRole'
 */
export type EnumPartnerRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PartnerRole'>
    


/**
 * Reference to a field of type 'IndustryInterest'
 */
export type EnumIndustryInterestFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IndustryInterest'>
    


/**
 * Reference to a field of type 'PreferredEarningStructure'
 */
export type EnumPreferredEarningStructureFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PreferredEarningStructure'>
    


/**
 * Reference to a field of type 'SalesChannel'
 */
export type EnumSalesChannelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SalesChannel'>
    


/**
 * Reference to a field of type 'PayoutStatus'
 */
export type EnumPayoutStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PayoutStatus'>
    


/**
 * Reference to a field of type 'PayoutMode'
 */
export type EnumPayoutModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PayoutMode'>
    


/**
 * Reference to a field of type 'EventType'
 */
export type EnumEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventType'>
    


/**
 * Reference to a field of type 'ProgramEnrollmentStatus'
 */
export type EnumProgramEnrollmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProgramEnrollmentStatus'>
    


/**
 * Reference to a field of type 'PartnerBannedReason'
 */
export type EnumPartnerBannedReasonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PartnerBannedReason'>
    


/**
 * Reference to a field of type 'Decimal'
 */
export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


/**
 * Reference to a field of type 'WebhookReceiver'
 */
export type EnumWebhookReceiverFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WebhookReceiver'>
    


/**
 * Reference to a field of type 'WorkflowTrigger'
 */
export type EnumWorkflowTriggerFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkflowTrigger'>
    


/**
 * Reference to a field of type 'WorkspaceRole'
 */
export type EnumWorkspaceRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkspaceRole'>
    

/**
 * Batch Payload for updateMany & deleteMany & createMany
 */
export type BatchPayload = {
  count: number
}


export type Datasource = {
  url?: string
}
export type Datasources = {
  db?: Datasource
}

export const defineExtension = runtime.Extensions.defineExtension as unknown as runtime.Types.Extensions.ExtendsHook<"define", TypeMapCb, runtime.Types.Extensions.DefaultArgs>
export type DefaultPrismaClient = PrismaClient
export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
export interface PrismaClientOptions {
  /**
   * Overwrites the datasource url from your schema.prisma file
   */
  datasources?: Datasources
  /**
   * Overwrites the datasource url from your schema.prisma file
   */
  datasourceUrl?: string
  /**
   * @default "colorless"
   */
  errorFormat?: ErrorFormat
  /**
   * @example
   * ```
   * // Shorthand for `emit: 'stdout'`
   * log: ['query', 'info', 'warn', 'error']
   * 
   * // Emit as events only
   * log: [
   *   { emit: 'event', level: 'query' },
   *   { emit: 'event', level: 'info' },
   *   { emit: 'event', level: 'warn' }
   *   { emit: 'event', level: 'error' }
   * ]
   * 
   * / Emit as events and log to stdout
   * og: [
   *  { emit: 'stdout', level: 'query' },
   *  { emit: 'stdout', level: 'info' },
   *  { emit: 'stdout', level: 'warn' }
   *  { emit: 'stdout', level: 'error' }
   * 
   * ```
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
   */
  log?: (LogLevel | LogDefinition)[]
  /**
   * The default values for transactionOptions
   * maxWait ?= 2000
   * timeout ?= 5000
   */
  transactionOptions?: {
    maxWait?: number
    timeout?: number
    isolationLevel?: TransactionIsolationLevel
  }
  /**
   * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
   */
  adapter?: runtime.SqlDriverAdapterFactory | null
  /**
   * Global configuration for omitting model fields by default.
   * 
   * @example
   * ```
   * const prisma = new PrismaClient({
   *   omit: {
   *     user: {
   *       password: true
   *     }
   *   }
   * })
   * ```
   */
  omit?: GlobalOmitConfig
}
export type GlobalOmitConfig = {
  bounty?: Prisma.BountyOmit
  bountyGroup?: Prisma.BountyGroupOmit
  bountySubmission?: Prisma.BountySubmissionOmit
  campaign?: Prisma.CampaignOmit
  campaignGroup?: Prisma.CampaignGroupOmit
  partnerComment?: Prisma.PartnerCommentOmit
  commission?: Prisma.CommissionOmit
  customer?: Prisma.CustomerOmit
  dashboard?: Prisma.DashboardOmit
  discount?: Prisma.DiscountOmit
  discountCode?: Prisma.DiscountCodeOmit
  domain?: Prisma.DomainOmit
  registeredDomain?: Prisma.RegisteredDomainOmit
  defaultDomains?: Prisma.DefaultDomainsOmit
  emailDomain?: Prisma.EmailDomainOmit
  folder?: Prisma.FolderOmit
  folderUser?: Prisma.FolderUserOmit
  folderAccessRequest?: Prisma.FolderAccessRequestOmit
  fraudRule?: Prisma.FraudRuleOmit
  fraudEventGroup?: Prisma.FraudEventGroupOmit
  fraudEvent?: Prisma.FraudEventOmit
  partnerGroup?: Prisma.PartnerGroupOmit
  partnerGroupDefaultLink?: Prisma.PartnerGroupDefaultLinkOmit
  integration?: Prisma.IntegrationOmit
  installedIntegration?: Prisma.InstalledIntegrationOmit
  invoice?: Prisma.InvoiceOmit
  jackson_index?: Prisma.jackson_indexOmit
  jackson_store?: Prisma.jackson_storeOmit
  jackson_ttl?: Prisma.jackson_ttlOmit
  link?: Prisma.LinkOmit
  message?: Prisma.MessageOmit
  yearInReview?: Prisma.YearInReviewOmit
  partnerRewind?: Prisma.PartnerRewindOmit
  programCategory?: Prisma.ProgramCategoryOmit
  programSimilarity?: Prisma.ProgramSimilarityOmit
  discoveredPartner?: Prisma.DiscoveredPartnerOmit
  notificationEmail?: Prisma.NotificationEmailOmit
  notificationPreference?: Prisma.NotificationPreferenceOmit
  partnerNotificationPreferences?: Prisma.PartnerNotificationPreferencesOmit
  oAuthApp?: Prisma.OAuthAppOmit
  oAuthCode?: Prisma.OAuthCodeOmit
  oAuthRefreshToken?: Prisma.OAuthRefreshTokenOmit
  partner?: Prisma.PartnerOmit
  partnerInvite?: Prisma.PartnerInviteOmit
  partnerUser?: Prisma.PartnerUserOmit
  partnerIndustryInterest?: Prisma.PartnerIndustryInterestOmit
  partnerPreferredEarningStructure?: Prisma.PartnerPreferredEarningStructureOmit
  partnerSalesChannel?: Prisma.PartnerSalesChannelOmit
  payout?: Prisma.PayoutOmit
  program?: Prisma.ProgramOmit
  programEnrollment?: Prisma.ProgramEnrollmentOmit
  programApplication?: Prisma.ProgramApplicationOmit
  reward?: Prisma.RewardOmit
  user?: Prisma.UserOmit
  account?: Prisma.AccountOmit
  session?: Prisma.SessionOmit
  tag?: Prisma.TagOmit
  linkTag?: Prisma.LinkTagOmit
  token?: Prisma.TokenOmit
  restrictedToken?: Prisma.RestrictedTokenOmit
  verificationToken?: Prisma.VerificationTokenOmit
  emailVerificationToken?: Prisma.EmailVerificationTokenOmit
  passwordResetToken?: Prisma.PasswordResetTokenOmit
  utmTemplate?: Prisma.UtmTemplateOmit
  webhook?: Prisma.WebhookOmit
  linkWebhook?: Prisma.LinkWebhookOmit
  workflow?: Prisma.WorkflowOmit
  project?: Prisma.ProjectOmit
  projectInvite?: Prisma.ProjectInviteOmit
  projectUsers?: Prisma.ProjectUsersOmit
  sentEmail?: Prisma.SentEmailOmit
}

/* Types for Logging */
export type LogLevel = 'info' | 'query' | 'warn' | 'error'
export type LogDefinition = {
  level: LogLevel
  emit: 'stdout' | 'event'
}

export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

export type GetLogType<T> = CheckIsLogLevel<
  T extends LogDefinition ? T['level'] : T
>;

export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
  ? GetLogType<T[number]>
  : never;

export type QueryEvent = {
  timestamp: Date
  query: string
  params: string
  duration: number
  target: string
}

export type LogEvent = {
  timestamp: Date
  message: string
  target: string
}
/* End Types for Logging */


export type PrismaAction =
  | 'findUnique'
  | 'findUniqueOrThrow'
  | 'findMany'
  | 'findFirst'
  | 'findFirstOrThrow'
  | 'create'
  | 'createMany'
  | 'createManyAndReturn'
  | 'update'
  | 'updateMany'
  | 'updateManyAndReturn'
  | 'upsert'
  | 'delete'
  | 'deleteMany'
  | 'executeRaw'
  | 'queryRaw'
  | 'aggregate'
  | 'count'
  | 'runCommandRaw'
  | 'findRaw'
  | 'groupBy'

/**
 * `PrismaClient` proxy available in interactive transactions.
 */
export type TransactionClient = Omit<DefaultPrismaClient, runtime.ITXClientDenyList>

